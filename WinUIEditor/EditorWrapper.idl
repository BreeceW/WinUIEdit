namespace WinUIEditor
{
	enum ScintillaMessage
	{
		AddText = 2001,
		AddStyledText = 2002,
		InsertText = 2003,
		ChangeInsertion = 2672,
		ClearAll = 2004,
		DeleteRange = 2645,
		ClearDocumentStyle = 2005,
		GetLength = 2006,
		GetCharAt = 2007,
		GetCurrentPos = 2008,
		GetAnchor = 2009,
		GetStyleAt = 2010,
		GetStyleIndexAt = 2038,
		Redo = 2011,
		SetUndoCollection = 2012,
		SelectAll = 2013,
		SetSavePoint = 2014,
		GetStyledText = 2015,
		GetStyledTextFull = 2778,
		CanRedo = 2016,
		MarkerLineFromHandle = 2017,
		MarkerDeleteHandle = 2018,
		MarkerHandleFromLine = 2732,
		MarkerNumberFromLine = 2733,
		GetUndoCollection = 2019,
		GetViewWS = 2020,
		SetViewWS = 2021,
		GetTabDrawMode = 2698,
		SetTabDrawMode = 2699,
		PositionFromPoint = 2022,
		PositionFromPointClose = 2023,
		GotoLine = 2024,
		GotoPos = 2025,
		SetAnchor = 2026,
		GetCurLine = 2027,
		GetEndStyled = 2028,
		ConvertEOLs = 2029,
		GetEOLMode = 2030,
		SetEOLMode = 2031,
		StartStyling = 2032,
		SetStyling = 2033,
		GetBufferedDraw = 2034,
		SetBufferedDraw = 2035,
		SetTabWidth = 2036,
		GetTabWidth = 2121,
		SetTabMinimumWidth = 2724,
		GetTabMinimumWidth = 2725,
		ClearTabStops = 2675,
		AddTabStop = 2676,
		GetNextTabStop = 2677,
		SetCodePage = 2037,
		SetFontLocale = 2760,
		GetFontLocale = 2761,
		GetIMEInteraction = 2678,
		SetIMEInteraction = 2679,
		MarkerDefine = 2040,
		MarkerSetFore = 2041,
		MarkerSetBack = 2042,
		MarkerSetBackSelected = 2292,
		MarkerSetForeTranslucent = 2294,
		MarkerSetBackTranslucent = 2295,
		MarkerSetBackSelectedTranslucent = 2296,
		MarkerSetStrokeWidth = 2297,
		MarkerEnableHighlight = 2293,
		MarkerAdd = 2043,
		MarkerDelete = 2044,
		MarkerDeleteAll = 2045,
		MarkerGet = 2046,
		MarkerNext = 2047,
		MarkerPrevious = 2048,
		MarkerDefinePixmap = 2049,
		MarkerAddSet = 2466,
		MarkerSetAlpha = 2476,
		MarkerGetLayer = 2734,
		MarkerSetLayer = 2735,
		SetMarginTypeN = 2240,
		GetMarginTypeN = 2241,
		SetMarginWidthN = 2242,
		GetMarginWidthN = 2243,
		SetMarginMaskN = 2244,
		GetMarginMaskN = 2245,
		SetMarginSensitiveN = 2246,
		GetMarginSensitiveN = 2247,
		SetMarginCursorN = 2248,
		GetMarginCursorN = 2249,
		SetMarginBackN = 2250,
		GetMarginBackN = 2251,
		SetMargins = 2252,
		GetMargins = 2253,
		StyleClearAll = 2050,
		StyleSetFore = 2051,
		StyleSetBack = 2052,
		StyleSetBold = 2053,
		StyleSetItalic = 2054,
		StyleSetSize = 2055,
		StyleSetFont = 2056,
		StyleSetEOLFilled = 2057,
		StyleResetDefault = 2058,
		StyleSetUnderline = 2059,
		StyleGetFore = 2481,
		StyleGetBack = 2482,
		StyleGetBold = 2483,
		StyleGetItalic = 2484,
		StyleGetSize = 2485,
		StyleGetFont = 2486,
		StyleGetEOLFilled = 2487,
		StyleGetUnderline = 2488,
		StyleGetCase = 2489,
		StyleGetCharacterSet = 2490,
		StyleGetVisible = 2491,
		StyleGetChangeable = 2492,
		StyleGetHotSpot = 2493,
		StyleSetCase = 2060,
		StyleSetSizeFractional = 2061,
		StyleGetSizeFractional = 2062,
		StyleSetWeight = 2063,
		StyleGetWeight = 2064,
		StyleSetCharacterSet = 2066,
		StyleSetHotSpot = 2409,
		StyleSetCheckMonospaced = 2254,
		StyleGetCheckMonospaced = 2255,
		StyleSetStretch = 2258,
		StyleGetStretch = 2259,
		StyleSetInvisibleRepresentation = 2256,
		StyleGetInvisibleRepresentation = 2257,
		SetElementColour = 2753,
		GetElementColour = 2754,
		ResetElementColour = 2755,
		GetElementIsSet = 2756,
		GetElementAllowsTranslucent = 2757,
		GetElementBaseColour = 2758,
		SetSelFore = 2067,
		SetSelBack = 2068,
		GetSelAlpha = 2477,
		SetSelAlpha = 2478,
		GetSelEOLFilled = 2479,
		SetSelEOLFilled = 2480,
		GetSelectionLayer = 2762,
		SetSelectionLayer = 2763,
		GetCaretLineLayer = 2764,
		SetCaretLineLayer = 2765,
		GetCaretLineHighlightSubLine = 2773,
		SetCaretLineHighlightSubLine = 2774,
		SetCaretFore = 2069,
		AssignCmdKey = 2070,
		ClearCmdKey = 2071,
		ClearAllCmdKeys = 2072,
		SetStylingEx = 2073,
		StyleSetVisible = 2074,
		GetCaretPeriod = 2075,
		SetCaretPeriod = 2076,
		SetWordChars = 2077,
		GetWordChars = 2646,
		SetCharacterCategoryOptimization = 2720,
		GetCharacterCategoryOptimization = 2721,
		BeginUndoAction = 2078,
		EndUndoAction = 2079,
		GetUndoSequence = 2799,
		GetUndoActions = 2790,
		SetUndoSavePoint = 2791,
		GetUndoSavePoint = 2792,
		SetUndoDetach = 2793,
		GetUndoDetach = 2794,
		SetUndoTentative = 2795,
		GetUndoTentative = 2796,
		SetUndoCurrent = 2797,
		GetUndoCurrent = 2798,
		PushUndoActionType = 2800,
		ChangeLastUndoActionText = 2801,
		GetUndoActionType = 2802,
		GetUndoActionPosition = 2803,
		GetUndoActionText = 2804,
		IndicSetStyle = 2080,
		IndicGetStyle = 2081,
		IndicSetFore = 2082,
		IndicGetFore = 2083,
		IndicSetUnder = 2510,
		IndicGetUnder = 2511,
		IndicSetHoverStyle = 2680,
		IndicGetHoverStyle = 2681,
		IndicSetHoverFore = 2682,
		IndicGetHoverFore = 2683,
		IndicSetFlags = 2684,
		IndicGetFlags = 2685,
		IndicSetStrokeWidth = 2751,
		IndicGetStrokeWidth = 2752,
		SetWhitespaceFore = 2084,
		SetWhitespaceBack = 2085,
		SetWhitespaceSize = 2086,
		GetWhitespaceSize = 2087,
		SetLineState = 2092,
		GetLineState = 2093,
		GetMaxLineState = 2094,
		GetCaretLineVisible = 2095,
		SetCaretLineVisible = 2096,
		GetCaretLineBack = 2097,
		SetCaretLineBack = 2098,
		GetCaretLineFrame = 2704,
		SetCaretLineFrame = 2705,
		StyleSetChangeable = 2099,
		AutoCShow = 2100,
		AutoCCancel = 2101,
		AutoCActive = 2102,
		AutoCPosStart = 2103,
		AutoCComplete = 2104,
		AutoCStops = 2105,
		AutoCSetSeparator = 2106,
		AutoCGetSeparator = 2107,
		AutoCSelect = 2108,
		AutoCSetCancelAtStart = 2110,
		AutoCGetCancelAtStart = 2111,
		AutoCSetFillUps = 2112,
		AutoCSetChooseSingle = 2113,
		AutoCGetChooseSingle = 2114,
		AutoCSetIgnoreCase = 2115,
		AutoCGetIgnoreCase = 2116,
		UserListShow = 2117,
		AutoCSetAutoHide = 2118,
		AutoCGetAutoHide = 2119,
		AutoCSetOptions = 2638,
		AutoCGetOptions = 2639,
		AutoCSetDropRestOfWord = 2270,
		AutoCGetDropRestOfWord = 2271,
		RegisterImage = 2405,
		ClearRegisteredImages = 2408,
		AutoCGetTypeSeparator = 2285,
		AutoCSetTypeSeparator = 2286,
		AutoCSetMaxWidth = 2208,
		AutoCGetMaxWidth = 2209,
		AutoCSetMaxHeight = 2210,
		AutoCGetMaxHeight = 2211,
		AutoCSetStyle = 2109,
		AutoCGetStyle = 2120,
		SetIndent = 2122,
		GetIndent = 2123,
		SetUseTabs = 2124,
		GetUseTabs = 2125,
		SetLineIndentation = 2126,
		GetLineIndentation = 2127,
		GetLineIndentPosition = 2128,
		GetColumn = 2129,
		CountCharacters = 2633,
		CountCodeUnits = 2715,
		SetHScrollBar = 2130,
		GetHScrollBar = 2131,
		SetIndentationGuides = 2132,
		GetIndentationGuides = 2133,
		SetHighlightGuide = 2134,
		GetHighlightGuide = 2135,
		GetLineEndPosition = 2136,
		GetCodePage = 2137,
		GetCaretFore = 2138,
		GetReadOnly = 2140,
		SetCurrentPos = 2141,
		SetSelectionStart = 2142,
		GetSelectionStart = 2143,
		SetSelectionEnd = 2144,
		GetSelectionEnd = 2145,
		SetEmptySelection = 2556,
		SetPrintMagnification = 2146,
		GetPrintMagnification = 2147,
		SetPrintColourMode = 2148,
		GetPrintColourMode = 2149,
		FindText = 2150,
		FindTextFull = 2196,
		FormatRange = 2151,
		FormatRangeFull = 2777,
		SetChangeHistory = 2780,
		GetChangeHistory = 2781,
		GetFirstVisibleLine = 2152,
		GetLine = 2153,
		GetLineCount = 2154,
		AllocateLines = 2089,
		SetMarginLeft = 2155,
		GetMarginLeft = 2156,
		SetMarginRight = 2157,
		GetMarginRight = 2158,
		GetModify = 2159,
		SetSel = 2160,
		GetSelText = 2161,
		GetTextRange = 2162,
		GetTextRangeFull = 2039,
		HideSelection = 2163,
		GetSelectionHidden = 2088,
		PointXFromPosition = 2164,
		PointYFromPosition = 2165,
		LineFromPosition = 2166,
		PositionFromLine = 2167,
		LineScroll = 2168,
		ScrollCaret = 2169,
		ScrollRange = 2569,
		ReplaceSel = 2170,
		SetReadOnly = 2171,
		Null = 2172,
		CanPaste = 2173,
		CanUndo = 2174,
		EmptyUndoBuffer = 2175,
		Undo = 2176,
		Cut = 2177,
		Copy = 2178,
		Paste = 2179,
		Clear = 2180,
		SetText = 2181,
		GetText = 2182,
		GetTextLength = 2183,
		GetDirectFunction = 2184,
		GetDirectStatusFunction = 2772,
		GetDirectPointer = 2185,
		SetOvertype = 2186,
		GetOvertype = 2187,
		SetCaretWidth = 2188,
		GetCaretWidth = 2189,
		SetTargetStart = 2190,
		GetTargetStart = 2191,
		SetTargetStartVirtualSpace = 2728,
		GetTargetStartVirtualSpace = 2729,
		SetTargetEnd = 2192,
		GetTargetEnd = 2193,
		SetTargetEndVirtualSpace = 2730,
		GetTargetEndVirtualSpace = 2731,
		SetTargetRange = 2686,
		GetTargetText = 2687,
		TargetFromSelection = 2287,
		TargetWholeDocument = 2690,
		ReplaceTarget = 2194,
		ReplaceTargetRE = 2195,
		ReplaceTargetMinimal = 2779,
		SearchInTarget = 2197,
		SetSearchFlags = 2198,
		GetSearchFlags = 2199,
		CallTipShow = 2200,
		CallTipCancel = 2201,
		CallTipActive = 2202,
		CallTipPosStart = 2203,
		CallTipSetPosStart = 2214,
		CallTipSetHlt = 2204,
		CallTipSetBack = 2205,
		CallTipSetFore = 2206,
		CallTipSetForeHlt = 2207,
		CallTipUseStyle = 2212,
		CallTipSetPosition = 2213,
		VisibleFromDocLine = 2220,
		DocLineFromVisible = 2221,
		WrapCount = 2235,
		SetFoldLevel = 2222,
		GetFoldLevel = 2223,
		GetLastChild = 2224,
		GetFoldParent = 2225,
		ShowLines = 2226,
		HideLines = 2227,
		GetLineVisible = 2228,
		GetAllLinesVisible = 2236,
		SetFoldExpanded = 2229,
		GetFoldExpanded = 2230,
		ToggleFold = 2231,
		ToggleFoldShowText = 2700,
		FoldDisplayTextSetStyle = 2701,
		FoldDisplayTextGetStyle = 2707,
		SetDefaultFoldDisplayText = 2722,
		GetDefaultFoldDisplayText = 2723,
		FoldLine = 2237,
		FoldChildren = 2238,
		ExpandChildren = 2239,
		FoldAll = 2662,
		EnsureVisible = 2232,
		SetAutomaticFold = 2663,
		GetAutomaticFold = 2664,
		SetFoldFlags = 2233,
		EnsureVisibleEnforcePolicy = 2234,
		SetTabIndents = 2260,
		GetTabIndents = 2261,
		SetBackSpaceUnIndents = 2262,
		GetBackSpaceUnIndents = 2263,
		SetMouseDwellTime = 2264,
		GetMouseDwellTime = 2265,
		WordStartPosition = 2266,
		WordEndPosition = 2267,
		IsRangeWord = 2691,
		SetIdleStyling = 2692,
		GetIdleStyling = 2693,
		SetWrapMode = 2268,
		GetWrapMode = 2269,
		SetWrapVisualFlags = 2460,
		GetWrapVisualFlags = 2461,
		SetWrapVisualFlagsLocation = 2462,
		GetWrapVisualFlagsLocation = 2463,
		SetWrapStartIndent = 2464,
		GetWrapStartIndent = 2465,
		SetWrapIndentMode = 2472,
		GetWrapIndentMode = 2473,
		SetLayoutCache = 2272,
		GetLayoutCache = 2273,
		SetScrollWidth = 2274,
		GetScrollWidth = 2275,
		SetScrollWidthTracking = 2516,
		GetScrollWidthTracking = 2517,
		TextWidth = 2276,
		SetEndAtLastLine = 2277,
		GetEndAtLastLine = 2278,
		TextHeight = 2279,
		SetVScrollBar = 2280,
		GetVScrollBar = 2281,
		AppendText = 2282,
		GetPhasesDraw = 2673,
		SetPhasesDraw = 2674,
		SetFontQuality = 2611,
		GetFontQuality = 2612,
		SetFirstVisibleLine = 2613,
		SetMultiPaste = 2614,
		GetMultiPaste = 2615,
		GetTag = 2616,
		LinesJoin = 2288,
		LinesSplit = 2289,
		SetFoldMarginColour = 2290,
		SetFoldMarginHiColour = 2291,
		SetAccessibility = 2702,
		GetAccessibility = 2703,
		LineDown = 2300,
		LineDownExtend = 2301,
		LineUp = 2302,
		LineUpExtend = 2303,
		CharLeft = 2304,
		CharLeftExtend = 2305,
		CharRight = 2306,
		CharRightExtend = 2307,
		WordLeft = 2308,
		WordLeftExtend = 2309,
		WordRight = 2310,
		WordRightExtend = 2311,
		Home = 2312,
		HomeExtend = 2313,
		LineEnd = 2314,
		LineEndExtend = 2315,
		DocumentStart = 2316,
		DocumentStartExtend = 2317,
		DocumentEnd = 2318,
		DocumentEndExtend = 2319,
		PageUp = 2320,
		PageUpExtend = 2321,
		PageDown = 2322,
		PageDownExtend = 2323,
		EditToggleOvertype = 2324,
		Cancel = 2325,
		DeleteBack = 2326,
		Tab = 2327,
		LineIndent = 2813,
		BackTab = 2328,
		LineDedent = 2814,
		NewLine = 2329,
		FormFeed = 2330,
		VCHome = 2331,
		VCHomeExtend = 2332,
		ZoomIn = 2333,
		ZoomOut = 2334,
		DelWordLeft = 2335,
		DelWordRight = 2336,
		DelWordRightEnd = 2518,
		LineCut = 2337,
		LineDelete = 2338,
		LineTranspose = 2339,
		LineReverse = 2354,
		LineDuplicate = 2404,
		LowerCase = 2340,
		UpperCase = 2341,
		LineScrollDown = 2342,
		LineScrollUp = 2343,
		DeleteBackNotLine = 2344,
		HomeDisplay = 2345,
		HomeDisplayExtend = 2346,
		LineEndDisplay = 2347,
		LineEndDisplayExtend = 2348,
		HomeWrap = 2349,
		HomeWrapExtend = 2450,
		LineEndWrap = 2451,
		LineEndWrapExtend = 2452,
		VCHomeWrap = 2453,
		VCHomeWrapExtend = 2454,
		LineCopy = 2455,
		MoveCaretInsideView = 2401,
		LineLength = 2350,
		BraceHighlight = 2351,
		BraceHighlightIndicator = 2498,
		BraceBadLight = 2352,
		BraceBadLightIndicator = 2499,
		BraceMatch = 2353,
		BraceMatchNext = 2369,
		GetViewEOL = 2355,
		SetViewEOL = 2356,
		GetDocPointer = 2357,
		SetDocPointer = 2358,
		SetModEventMask = 2359,
		GetEdgeColumn = 2360,
		SetEdgeColumn = 2361,
		GetEdgeMode = 2362,
		SetEdgeMode = 2363,
		GetEdgeColour = 2364,
		SetEdgeColour = 2365,
		MultiEdgeAddLine = 2694,
		MultiEdgeClearAll = 2695,
		GetMultiEdgeColumn = 2749,
		SearchAnchor = 2366,
		SearchNext = 2367,
		SearchPrev = 2368,
		LinesOnScreen = 2370,
		UsePopUp = 2371,
		SelectionIsRectangle = 2372,
		SetZoom = 2373,
		GetZoom = 2374,
		CreateDocument = 2375,
		AddRefDocument = 2376,
		ReleaseDocument = 2377,
		GetDocumentOptions = 2379,
		GetModEventMask = 2378,
		SetCommandEvents = 2717,
		GetCommandEvents = 2718,
		SetFocus = 2380,
		GetFocus = 2381,
		SetStatus = 2382,
		GetStatus = 2383,
		SetMouseDownCaptures = 2384,
		GetMouseDownCaptures = 2385,
		SetMouseWheelCaptures = 2696,
		GetMouseWheelCaptures = 2697,
		SetCursor = 2386,
		GetCursor = 2387,
		SetControlCharSymbol = 2388,
		GetControlCharSymbol = 2389,
		WordPartLeft = 2390,
		WordPartLeftExtend = 2391,
		WordPartRight = 2392,
		WordPartRightExtend = 2393,
		SetVisiblePolicy = 2394,
		DelLineLeft = 2395,
		DelLineRight = 2396,
		SetXOffset = 2397,
		GetXOffset = 2398,
		ChooseCaretX = 2399,
		GrabFocus = 2400,
		SetXCaretPolicy = 2402,
		SetYCaretPolicy = 2403,
		SetPrintWrapMode = 2406,
		GetPrintWrapMode = 2407,
		SetHotspotActiveFore = 2410,
		GetHotspotActiveFore = 2494,
		SetHotspotActiveBack = 2411,
		GetHotspotActiveBack = 2495,
		SetHotspotActiveUnderline = 2412,
		GetHotspotActiveUnderline = 2496,
		SetHotspotSingleLine = 2421,
		GetHotspotSingleLine = 2497,
		ParaDown = 2413,
		ParaDownExtend = 2414,
		ParaUp = 2415,
		ParaUpExtend = 2416,
		PositionBefore = 2417,
		PositionAfter = 2418,
		PositionRelative = 2670,
		PositionRelativeCodeUnits = 2716,
		CopyRange = 2419,
		CopyText = 2420,
		SetSelectionMode = 2422,
		ChangeSelectionMode = 2659,
		GetSelectionMode = 2423,
		SetMoveExtendsSelection = 2719,
		GetMoveExtendsSelection = 2706,
		GetLineSelStartPosition = 2424,
		GetLineSelEndPosition = 2425,
		LineDownRectExtend = 2426,
		LineUpRectExtend = 2427,
		CharLeftRectExtend = 2428,
		CharRightRectExtend = 2429,
		HomeRectExtend = 2430,
		VCHomeRectExtend = 2431,
		LineEndRectExtend = 2432,
		PageUpRectExtend = 2433,
		PageDownRectExtend = 2434,
		StutteredPageUp = 2435,
		StutteredPageUpExtend = 2436,
		StutteredPageDown = 2437,
		StutteredPageDownExtend = 2438,
		WordLeftEnd = 2439,
		WordLeftEndExtend = 2440,
		WordRightEnd = 2441,
		WordRightEndExtend = 2442,
		SetWhitespaceChars = 2443,
		GetWhitespaceChars = 2647,
		SetPunctuationChars = 2648,
		GetPunctuationChars = 2649,
		SetCharsDefault = 2444,
		AutoCGetCurrent = 2445,
		AutoCGetCurrentText = 2610,
		AutoCSetCaseInsensitiveBehaviour = 2634,
		AutoCGetCaseInsensitiveBehaviour = 2635,
		AutoCSetMulti = 2636,
		AutoCGetMulti = 2637,
		AutoCSetOrder = 2660,
		AutoCGetOrder = 2661,
		Allocate = 2446,
		TargetAsUTF8 = 2447,
		SetLengthForEncode = 2448,
		EncodedFromUTF8 = 2449,
		FindColumn = 2456,
		GetCaretSticky = 2457,
		SetCaretSticky = 2458,
		ToggleCaretSticky = 2459,
		SetPasteConvertEndings = 2467,
		GetPasteConvertEndings = 2468,
		ReplaceRectangular = 2771,
		SelectionDuplicate = 2469,
		SetCaretLineBackAlpha = 2470,
		GetCaretLineBackAlpha = 2471,
		SetCaretStyle = 2512,
		GetCaretStyle = 2513,
		SetIndicatorCurrent = 2500,
		GetIndicatorCurrent = 2501,
		SetIndicatorValue = 2502,
		GetIndicatorValue = 2503,
		IndicatorFillRange = 2504,
		IndicatorClearRange = 2505,
		IndicatorAllOnFor = 2506,
		IndicatorValueAt = 2507,
		IndicatorStart = 2508,
		IndicatorEnd = 2509,
		SetPositionCache = 2514,
		GetPositionCache = 2515,
		SetLayoutThreads = 2775,
		GetLayoutThreads = 2776,
		CopyAllowLine = 2519,
		CutAllowLine = 2810,
		SetCopySeparator = 2811,
		GetCopySeparator = 2812,
		GetCharacterPointer = 2520,
		GetRangePointer = 2643,
		GetGapPosition = 2644,
		IndicSetAlpha = 2523,
		IndicGetAlpha = 2524,
		IndicSetOutlineAlpha = 2558,
		IndicGetOutlineAlpha = 2559,
		SetExtraAscent = 2525,
		GetExtraAscent = 2526,
		SetExtraDescent = 2527,
		GetExtraDescent = 2528,
		MarkerSymbolDefined = 2529,
		MarginSetText = 2530,
		MarginGetText = 2531,
		MarginSetStyle = 2532,
		MarginGetStyle = 2533,
		MarginSetStyles = 2534,
		MarginGetStyles = 2535,
		MarginTextClearAll = 2536,
		MarginSetStyleOffset = 2537,
		MarginGetStyleOffset = 2538,
		SetMarginOptions = 2539,
		GetMarginOptions = 2557,
		AnnotationSetText = 2540,
		AnnotationGetText = 2541,
		AnnotationSetStyle = 2542,
		AnnotationGetStyle = 2543,
		AnnotationSetStyles = 2544,
		AnnotationGetStyles = 2545,
		AnnotationGetLines = 2546,
		AnnotationClearAll = 2547,
		AnnotationSetVisible = 2548,
		AnnotationGetVisible = 2549,
		AnnotationSetStyleOffset = 2550,
		AnnotationGetStyleOffset = 2551,
		ReleaseAllExtendedStyles = 2552,
		AllocateExtendedStyles = 2553,
		AddUndoAction = 2560,
		CharPositionFromPoint = 2561,
		CharPositionFromPointClose = 2562,
		SetMouseSelectionRectangularSwitch = 2668,
		GetMouseSelectionRectangularSwitch = 2669,
		SetMultipleSelection = 2563,
		GetMultipleSelection = 2564,
		SetAdditionalSelectionTyping = 2565,
		GetAdditionalSelectionTyping = 2566,
		SetAdditionalCaretsBlink = 2567,
		GetAdditionalCaretsBlink = 2568,
		SetAdditionalCaretsVisible = 2608,
		GetAdditionalCaretsVisible = 2609,
		GetSelections = 2570,
		GetSelectionEmpty = 2650,
		ClearSelections = 2571,
		SetSelection = 2572,
		AddSelection = 2573,
		SelectionFromPoint = 2474,
		DropSelectionN = 2671,
		SetMainSelection = 2574,
		GetMainSelection = 2575,
		SetSelectionNCaret = 2576,
		GetSelectionNCaret = 2577,
		SetSelectionNAnchor = 2578,
		GetSelectionNAnchor = 2579,
		SetSelectionNCaretVirtualSpace = 2580,
		GetSelectionNCaretVirtualSpace = 2581,
		SetSelectionNAnchorVirtualSpace = 2582,
		GetSelectionNAnchorVirtualSpace = 2583,
		SetSelectionNStart = 2584,
		GetSelectionNStart = 2585,
		GetSelectionNStartVirtualSpace = 2726,
		SetSelectionNEnd = 2586,
		GetSelectionNEndVirtualSpace = 2727,
		GetSelectionNEnd = 2587,
		SetRectangularSelectionCaret = 2588,
		GetRectangularSelectionCaret = 2589,
		SetRectangularSelectionAnchor = 2590,
		GetRectangularSelectionAnchor = 2591,
		SetRectangularSelectionCaretVirtualSpace = 2592,
		GetRectangularSelectionCaretVirtualSpace = 2593,
		SetRectangularSelectionAnchorVirtualSpace = 2594,
		GetRectangularSelectionAnchorVirtualSpace = 2595,
		SetVirtualSpaceOptions = 2596,
		GetVirtualSpaceOptions = 2597,
		SetRectangularSelectionModifier = 2598,
		GetRectangularSelectionModifier = 2599,
		SetAdditionalSelFore = 2600,
		SetAdditionalSelBack = 2601,
		SetAdditionalSelAlpha = 2602,
		GetAdditionalSelAlpha = 2603,
		SetAdditionalCaretFore = 2604,
		GetAdditionalCaretFore = 2605,
		RotateSelection = 2606,
		SwapMainAnchorCaret = 2607,
		MultipleSelectAddNext = 2688,
		MultipleSelectAddEach = 2689,
		ChangeLexerState = 2617,
		ContractedFoldNext = 2618,
		VerticalCentreCaret = 2619,
		MoveSelectedLinesUp = 2620,
		MoveSelectedLinesDown = 2621,
		SetIdentifier = 2622,
		GetIdentifier = 2623,
		RGBAImageSetWidth = 2624,
		RGBAImageSetHeight = 2625,
		RGBAImageSetScale = 2651,
		MarkerDefineRGBAImage = 2626,
		RegisterRGBAImage = 2627,
		ScrollToStart = 2628,
		ScrollToEnd = 2629,
		SetTechnology = 2630,
		GetTechnology = 2631,
		CreateLoader = 2632,
		FindIndicatorShow = 2640,
		FindIndicatorFlash = 2641,
		FindIndicatorHide = 2642,
		VCHomeDisplay = 2652,
		VCHomeDisplayExtend = 2653,
		GetCaretLineVisibleAlways = 2654,
		SetCaretLineVisibleAlways = 2655,
		SetLineEndTypesAllowed = 2656,
		GetLineEndTypesAllowed = 2657,
		GetLineEndTypesActive = 2658,
		SetRepresentation = 2665,
		GetRepresentation = 2666,
		ClearRepresentation = 2667,
		ClearAllRepresentations = 2770,
		SetRepresentationAppearance = 2766,
		GetRepresentationAppearance = 2767,
		SetRepresentationColour = 2768,
		GetRepresentationColour = 2769,
		EOLAnnotationSetText = 2740,
		EOLAnnotationGetText = 2741,
		EOLAnnotationSetStyle = 2742,
		EOLAnnotationGetStyle = 2743,
		EOLAnnotationClearAll = 2744,
		EOLAnnotationSetVisible = 2745,
		EOLAnnotationGetVisible = 2746,
		EOLAnnotationSetStyleOffset = 2747,
		EOLAnnotationGetStyleOffset = 2748,
		SupportsFeature = 2750,
		GetLineCharacterIndex = 2710,
		AllocateLineCharacterIndex = 2711,
		ReleaseLineCharacterIndex = 2712,
		LineFromIndexPosition = 2713,
		IndexPositionFromLine = 2714,
		StartRecord = 3001,
		StopRecord = 3002,
		GetLexer = 4002,
		Colourise = 4003,
		SetProperty = 4004,
		SetKeyWords = 4005,
		GetProperty = 4008,
		GetPropertyExpanded = 4009,
		GetPropertyInt = 4010,
		GetLexerLanguage = 4012,
		PrivateLexerCall = 4013,
		PropertyNames = 4014,
		PropertyType = 4015,
		DescribeProperty = 4016,
		DescribeKeyWordSets = 4017,
		GetLineEndTypesSupported = 4018,
		AllocateSubStyles = 4020,
		GetSubStylesStart = 4021,
		GetSubStylesLength = 4022,
		GetStyleFromSubStyle = 4027,
		GetPrimaryStyleFromStyle = 4028,
		FreeSubStyles = 4023,
		SetIdentifiers = 4024,
		DistanceToSecondaryStyles = 4025,
		GetSubStyleBases = 4026,
		GetNamedStyles = 4029,
		NameOfStyle = 4030,
		TagsOfStyle = 4031,
		DescriptionOfStyle = 4032,
		SetILexer = 4033,
		GetBidirectional = 2708,
		SetBidirectional = 2709,
	};

	enum WhiteSpace
	{
		Invisible = 0,
		VisibleAlways = 1,
		VisibleAfterIndent = 2,
		VisibleOnlyInIndent = 3,
	};

	enum TabDrawMode
	{
		LongArrow = 0,
		StrikeOut = 1,
	};

	enum EndOfLine
	{
		CrLf = 0,
		Cr = 1,
		Lf = 2,
	};

	enum IMEInteraction
	{
		Windowed = 0,
		Inline = 1,
	};

	enum Alpha
	{
		Transparent = 0,
		Opaque = 255,
		NoAlpha = 256,
	};

	enum CursorShape
	{
		Normal = -1,
		Arrow = 2,
		Wait = 4,
		ReverseArrow = 7,
	};

	enum MarkerSymbol
	{
		Circle = 0,
		RoundRect = 1,
		Arrow = 2,
		SmallRect = 3,
		ShortArrow = 4,
		Empty = 5,
		ArrowDown = 6,
		Minus = 7,
		Plus = 8,
		VLine = 9,
		LCorner = 10,
		TCorner = 11,
		BoxPlus = 12,
		BoxPlusConnected = 13,
		BoxMinus = 14,
		BoxMinusConnected = 15,
		LCornerCurve = 16,
		TCornerCurve = 17,
		CirclePlus = 18,
		CirclePlusConnected = 19,
		CircleMinus = 20,
		CircleMinusConnected = 21,
		Background = 22,
		DotDotDot = 23,
		Arrows = 24,
		Pixmap = 25,
		FullRect = 26,
		LeftRect = 27,
		Available = 28,
		Underline = 29,
		RgbaImage = 30,
		Bookmark = 31,
		VerticalBookmark = 32,
		Bar = 33,
		Character = 10000,
	};

	enum MarkerOutline
	{
		HistoryRevertedToOrigin = 21,
		HistorySaved = 22,
		HistoryModified = 23,
		HistoryRevertedToModified = 24,
		FolderEnd = 25,
		FolderOpenMid = 26,
		FolderMidTail = 27,
		FolderTail = 28,
		FolderSub = 29,
		Folder = 30,
		FolderOpen = 31,
	};

	enum MarginType
	{
		Symbol = 0,
		Number = 1,
		Back = 2,
		Fore = 3,
		Text = 4,
		RText = 5,
		Colour = 6,
	};

	enum StylesCommon
	{
		Default = 32,
		LineNumber = 33,
		BraceLight = 34,
		BraceBad = 35,
		ControlChar = 36,
		IndentGuide = 37,
		CallTip = 38,
		FoldDisplayText = 39,
		LastPredefined = 39,
		Max = 255,
	};

	enum CharacterSet
	{
		Ansi = 0,
		Default = 1,
		Baltic = 186,
		ChineseBig5 = 136,
		EastEurope = 238,
		GB2312 = 134,
		Greek = 161,
		Hangul = 129,
		Mac = 77,
		Oem = 255,
		Russian = 204,
		Oem866 = 866,
		Cyrillic = 1251,
		ShiftJis = 128,
		Symbol = 2,
		Turkish = 162,
		Johab = 130,
		Hebrew = 177,
		Arabic = 178,
		Vietnamese = 163,
		Thai = 222,
		Iso885915 = 1000,
	};

	enum CaseVisible
	{
		Mixed = 0,
		Upper = 1,
		Lower = 2,
		Camel = 3,
	};

	enum FontWeight
	{
		Normal = 400,
		SemiBold = 600,
		Bold = 700,
	};

	enum FontStretch
	{
		UltraCondensed = 1,
		ExtraCondensed = 2,
		Condensed = 3,
		SemiCondensed = 4,
		Normal = 5,
		SemiExpanded = 6,
		Expanded = 7,
		ExtraExpanded = 8,
		UltraExpanded = 9,
	};

	enum Element
	{
		List = 0,
		ListBack = 1,
		ListSelected = 2,
		ListSelectedBack = 3,
		SelectionText = 10,
		SelectionBack = 11,
		SelectionAdditionalText = 12,
		SelectionAdditionalBack = 13,
		SelectionSecondaryText = 14,
		SelectionSecondaryBack = 15,
		SelectionInactiveText = 16,
		SelectionInactiveBack = 17,
		SelectionInactiveAdditionalText = 18,
		SelectionInactiveAdditionalBack = 19,
		Caret = 40,
		CaretAdditional = 41,
		CaretLineBack = 50,
		WhiteSpace = 60,
		WhiteSpaceBack = 61,
		HotSpotActive = 70,
		HotSpotActiveBack = 71,
		FoldLine = 80,
		HiddenLine = 81,
	};

	enum Layer
	{
		Base = 0,
		UnderText = 1,
		OverText = 2,
	};

	enum IndicatorStyle
	{
		Plain = 0,
		Squiggle = 1,
		TT = 2,
		Diagonal = 3,
		Strike = 4,
		Hidden = 5,
		Box = 6,
		RoundBox = 7,
		StraightBox = 8,
		Dash = 9,
		Dots = 10,
		SquiggleLow = 11,
		DotBox = 12,
		SquigglePixmap = 13,
		CompositionThick = 14,
		CompositionThin = 15,
		FullBox = 16,
		TextFore = 17,
		Point = 18,
		PointCharacter = 19,
		Gradient = 20,
		GradientCentre = 21,
		PointTop = 22,
		Container = 8,
		Ime = 32,
		ImeMax = 35,
		Max = 35,
	};

	enum IndicatorNumbers
	{
		Container = 8,
		Ime = 32,
		ImeMax = 35,
		HistoryRevertedToOriginInsertion = 36,
		HistoryRevertedToOriginDeletion = 37,
		HistorySavedInsertion = 38,
		HistorySavedDeletion = 39,
		HistoryModifiedInsertion = 40,
		HistoryModifiedDeletion = 41,
		HistoryRevertedToModifiedInsertion = 42,
		HistoryRevertedToModifiedDeletion = 43,
		Max = 43,
	};

	enum IndicValue
	{
		Bit = 16777216,
		Mask = 16777215,
	};

	enum IndicFlag
	{
		None = 0,
		ValueFore = 1,
	};

	enum AutoCompleteOption
	{
		Normal = 0,
		FixedSize = 1,
		SelectFirstItem = 2,
	};

	enum IndentView
	{
		None = 0,
		Real = 1,
		LookForward = 2,
		LookBoth = 3,
	};

	enum PrintOption
	{
		Normal = 0,
		InvertLight = 1,
		BlackOnWhite = 2,
		ColourOnWhite = 3,
		ColourOnWhiteDefaultBG = 4,
		ScreenColours = 5,
	};

	[flags]
	enum FindOption
	{
		None = 0,
		WholeWord = 2,
		MatchCase = 4,
		WordStart = 1048576,
		RegExp = 2097152,
		Posix = 4194304,
		Cxx11RegEx = 8388608,
	};

	enum ChangeHistoryOption
	{
		Disabled = 0,
		Enabled = 1,
		Markers = 2,
		Indicators = 4,
	};

	enum FoldLevel
	{
		None = 0,
		Base = 1024,
		WhiteFlag = 4096,
		HeaderFlag = 8192,
		NumberMask = 4095,
	};

	enum FoldDisplayTextStyle
	{
		Hidden = 0,
		Standard = 1,
		Boxed = 2,
	};

	enum FoldAction
	{
		Contract = 0,
		Expand = 1,
		Toggle = 2,
		ContractEveryLevel = 4,
	};

	enum AutomaticFold
	{
		None = 0,
		Show = 1,
		Click = 2,
		Change = 4,
	};

	[flags]
	enum FoldFlag
	{
		None = 0,
		LineBeforeExpanded = 2,
		LineBeforeContracted = 4,
		LineAfterExpanded = 8,
		LineAfterContracted = 16,
		LevelNumbers = 64,
		LineState = 128,
	};

	enum IdleStyling
	{
		None = 0,
		ToVisible = 1,
		AfterVisible = 2,
		All = 3,
	};

	enum Wrap
	{
		None = 0,
		Word = 1,
		Char = 2,
		WhiteSpace = 3,
	};

	enum WrapVisualFlag
	{
		None = 0,
		End = 1,
		Start = 2,
		Margin = 4,
	};

	enum WrapVisualLocation
	{
		Default = 0,
		EndByText = 1,
		StartByText = 2,
	};

	enum WrapIndentMode
	{
		Fixed = 0,
		Same = 1,
		Indent = 2,
		DeepIndent = 3,
	};

	enum LineCache
	{
		None = 0,
		Caret = 1,
		Page = 2,
		Document = 3,
	};

	enum PhasesDraw
	{
		One = 0,
		Two = 1,
		Multiple = 2,
	};

	enum FontQuality
	{
		QualityMask = 15,
		QualityDefault = 0,
		QualityNonAntialiased = 1,
		QualityAntialiased = 2,
		QualityLcdOptimized = 3,
	};

	enum MultiPaste
	{
		Once = 0,
		Each = 1,
	};

	enum Accessibility
	{
		Disabled = 0,
		Enabled = 1,
	};

	enum EdgeVisualStyle
	{
		None = 0,
		Line = 1,
		Background = 2,
		MultiLine = 3,
	};

	enum PopUp
	{
		Never = 0,
		All = 1,
		Text = 2,
	};

	[flags]
	enum DocumentOption
	{
		Default = 0,
		StylesNone = 1,
		TextLarge = 256,
	};

	enum Status
	{
		Ok = 0,
		Failure = 1,
		BadAlloc = 2,
		WarnStart = 1000,
		RegEx = 1001,
	};

	enum VisiblePolicy
	{
		Slop = 1,
		Strict = 4,
	};

	[flags]
	enum CaretPolicy
	{
		Slop = 1,
		Strict = 4,
		Jumps = 16,
		Even = 8,
	};

	enum SelectionMode
	{
		Stream = 0,
		Rectangle = 1,
		Lines = 2,
		Thin = 3,
	};

	enum CaseInsensitiveBehaviour
	{
		RespectCase = 0,
		IgnoreCase = 1,
	};

	enum MultiAutoComplete
	{
		Once = 0,
		Each = 1,
	};

	enum Ordering
	{
		PreSorted = 0,
		PerformSort = 1,
		Custom = 2,
	};

	enum CaretSticky
	{
		Off = 0,
		On = 1,
		WhiteSpace = 2,
	};

	[flags]
	enum CaretStyle
	{
		Invisible = 0,
		Line = 1,
		Block = 2,
		OverstrikeBar = 0,
		OverstrikeBlock = 16,
		Curses = 32,
		InsMask = 15,
		BlockAfter = 256,
	};

	enum MarginOption
	{
		None = 0,
		SubLineSelect = 1,
	};

	enum AnnotationVisible
	{
		Hidden = 0,
		Standard = 1,
		Boxed = 2,
		Indented = 3,
	};

	enum UndoFlags
	{
		None = 0,
		MayCoalesce = 1,
	};

	enum VirtualSpace
	{
		None = 0,
		RectangularSelection = 1,
		UserAccessible = 2,
		NoWrapLineStart = 4,
	};

	enum Technology
	{
		Default = 0,
		DirectWrite = 1,
		DirectWriteRetain = 2,
		DirectWriteDC = 3,
	};

	enum LineEndType
	{
		Default = 0,
		Unicode = 1,
	};

	[flags]
	enum RepresentationAppearance
	{
		Plain = 0,
		Blob = 1,
		Colour = 16,
	};

	enum EOLAnnotationVisible
	{
		Hidden = 0,
		Standard = 1,
		Boxed = 2,
		Stadium = 256,
		FlatCircle = 257,
		AngleCircle = 258,
		CircleFlat = 272,
		Flats = 273,
		AngleFlat = 274,
		CircleAngle = 288,
		FlatAngle = 289,
		Angles = 290,
	};

	enum Supports
	{
		LineDrawsFinal = 0,
		PixelDivisions = 1,
		FractionalStrokeWidth = 2,
		TranslucentStroke = 3,
		PixelModification = 4,
		ThreadSafeMeasureWidths = 5,
	};

	[flags]
	enum LineCharacterIndexType
	{
		None = 0,
		Utf32 = 1,
		Utf16 = 2,
	};

	enum TypeProperty
	{
		Boolean = 0,
		Integer = 1,
		String = 2,
	};

	[flags]
	enum ModificationFlags
	{
		None = 0,
		InsertText = 1,
		DeleteText = 2,
		ChangeStyle = 4,
		ChangeFold = 8,
		User = 16,
		Undo = 32,
		Redo = 64,
		MultiStepUndoRedo = 128,
		LastStepInUndoRedo = 256,
		ChangeMarker = 512,
		BeforeInsert = 1024,
		BeforeDelete = 2048,
		MultilineUndoRedo = 4096,
		StartAction = 8192,
		ChangeIndicator = 16384,
		ChangeLineState = 32768,
		ChangeMargin = 65536,
		ChangeAnnotation = 131072,
		Container = 262144,
		LexerState = 524288,
		InsertCheck = 1048576,
		ChangeTabStops = 2097152,
		ChangeEOLAnnotation = 4194304,
		EventMaskAll = 8388607,
	};

	[flags]
	enum Update
	{
		None = 0,
		Content = 1,
		Selection = 2,
		VScroll = 4,
		HScroll = 8,
	};

	enum FocusChange
	{
		Change = 768,
		Setfocus = 512,
		Killfocus = 256,
	};

	enum Keys
	{
		Down = 300,
		Up = 301,
		Left = 302,
		Right = 303,
		Home = 304,
		End = 305,
		Prior = 306,
		Next = 307,
		Delete = 308,
		Insert = 309,
		Escape = 7,
		Back = 8,
		Tab = 9,
		Return = 13,
		Add = 310,
		Subtract = 311,
		Divide = 312,
		Win = 313,
		RWin = 314,
		Menu = 315,
	};

	[flags]
	enum KeyMod
	{
		Norm = 0,
		Shift = 1,
		Ctrl = 2,
		Alt = 4,
		Super = 8,
		Meta = 16,
	};

	enum CompletionMethods
	{
		FillUp = 1,
		DoubleClick = 2,
		Tab = 3,
		Newline = 4,
		Command = 5,
		SingleChoice = 6,
	};

	enum CharacterSource
	{
		DirectInput = 0,
		TentativeInput = 1,
		ImeResult = 2,
	};

	enum Bidirectional
	{
		Disabled = 0,
		L2r = 1,
		R2l = 2,
	};

	enum Lexer
	{
		Container = 0,
		Null = 1,
		Python = 2,
		Cpp = 3,
		Html = 4,
		Xml = 5,
		Perl = 6,
		Sql = 7,
		Vb = 8,
		Properties = 9,
		Errorlist = 10,
		Makefile = 11,
		Batch = 12,
		Xcode = 13,
		Latex = 14,
		Lua = 15,
		Diff = 16,
		Conf = 17,
		Pascal = 18,
		Ave = 19,
		Ada = 20,
		Lisp = 21,
		Ruby = 22,
		Eiffel = 23,
		Eiffelkw = 24,
		Tcl = 25,
		Nncrontab = 26,
		Bullant = 27,
		Vbscript = 28,
		Baan = 31,
		Matlab = 32,
		Scriptol = 33,
		Asm = 34,
		Cppnocase = 35,
		Fortran = 36,
		F77 = 37,
		Css = 38,
		Pov = 39,
		Lout = 40,
		Escript = 41,
		Ps = 42,
		Nsis = 43,
		Mmixal = 44,
		Clw = 45,
		Clwnocase = 46,
		Lot = 47,
		Yaml = 48,
		Tex = 49,
		Metapost = 50,
		Powerbasic = 51,
		Forth = 52,
		Erlang = 53,
		Octave = 54,
		Mssql = 55,
		Verilog = 56,
		Kix = 57,
		Gui4cli = 58,
		Specman = 59,
		Au3 = 60,
		Apdl = 61,
		Bash = 62,
		Asn1 = 63,
		Vhdl = 64,
		Caml = 65,
		Blitzbasic = 66,
		Purebasic = 67,
		Haskell = 68,
		Phpscript = 69,
		Tads3 = 70,
		Rebol = 71,
		Smalltalk = 72,
		Flagship = 73,
		Csound = 74,
		Freebasic = 75,
		Innosetup = 76,
		Opal = 77,
		Spice = 78,
		D = 79,
		Cmake = 80,
		Gap = 81,
		Plm = 82,
		Progress = 83,
		Abaqus = 84,
		Asymptote = 85,
		R = 86,
		Magik = 87,
		Powershell = 88,
		Mysql = 89,
		Po = 90,
		Tal = 91,
		Cobol = 92,
		Tacl = 93,
		Sorcus = 94,
		Powerpro = 95,
		Nimrod = 96,
		Sml = 97,
		Markdown = 98,
		Txt2tags = 99,
		A68k = 100,
		Modula = 101,
		Coffeescript = 102,
		Tcmd = 103,
		Avs = 104,
		Ecl = 105,
		Oscript = 106,
		Visualprolog = 107,
		Literatehaskell = 108,
		Sttxt = 109,
		Kvirc = 110,
		Rust = 111,
		Dmap = 112,
		As = 113,
		Dmis = 114,
		Registry = 115,
		Bibtex = 116,
		Srec = 117,
		Ihex = 118,
		Tehex = 119,
		Json = 120,
		Edifact = 121,
		Indent = 122,
		Maxima = 123,
		Stata = 124,
		Sas = 125,
		Nim = 126,
		Cil = 127,
		X12 = 128,
		Dataflex = 129,
		Hollywood = 130,
		Raku = 131,
		Fsharp = 132,
		Julia = 133,
		Asciidoc = 134,
		Gdscript = 135,
		Toml = 136,
		Troff = 137,
		Dart = 138,
		Zig = 139,
		Nix = 140,
		Automatic = 1000,
	};

	enum EditorConstants
	{
		InvalidPosition = -1,
		ScCpUtf8 = 65001,
		MarkerMax = 31,
		ScMaskHistory = 31457280,
		ScMaskFolders = -33554432,
		ScMaxMargin = 4,
		ScFontSizeMultiplier = 100,
		ScTimeForever = 10000000,
		KeywordsetMax = 8,
	};

	enum Python
	{
		PDefault = 0,
		PCommentline = 1,
		PNumber = 2,
		PString = 3,
		PCharacter = 4,
		PWord = 5,
		PTriple = 6,
		PTripledouble = 7,
		PClassname = 8,
		PDefname = 9,
		POperator = 10,
		PIdentifier = 11,
		PCommentblock = 12,
		PStringeol = 13,
		PWord2 = 14,
		PDecorator = 15,
		PFstring = 16,
		PFcharacter = 17,
		PFtriple = 18,
		PFtripledouble = 19,
		PAttribute = 20,
	};

	enum Nimrod
	{
		PDefault = 0,
		PCommentline = 1,
		PNumber = 2,
		PString = 3,
		PCharacter = 4,
		PWord = 5,
		PTriple = 6,
		PTripledouble = 7,
		PClassname = 8,
		PDefname = 9,
		POperator = 10,
		PIdentifier = 11,
		PCommentblock = 12,
		PStringeol = 13,
		PWord2 = 14,
		PDecorator = 15,
		PFstring = 16,
		PFcharacter = 17,
		PFtriple = 18,
		PFtripledouble = 19,
		PAttribute = 20,
	};

	enum Cpp
	{
		CDefault = 0,
		CComment = 1,
		CCommentline = 2,
		CCommentdoc = 3,
		CNumber = 4,
		CWord = 5,
		CString = 6,
		CCharacter = 7,
		CUuid = 8,
		CPreprocessor = 9,
		COperator = 10,
		CIdentifier = 11,
		CStringeol = 12,
		CVerbatim = 13,
		CRegex = 14,
		CCommentlinedoc = 15,
		CWord2 = 16,
		CCommentdockeyword = 17,
		CCommentdockeyworderror = 18,
		CGlobalclass = 19,
		CStringraw = 20,
		CTripleverbatim = 21,
		CHashquotedstring = 22,
		CPreprocessorcomment = 23,
		CPreprocessorcommentdoc = 24,
		CUserliteral = 25,
		CTaskmarker = 26,
		CEscapesequence = 27,
	};

	enum BullAnt
	{
		CDefault = 0,
		CComment = 1,
		CCommentline = 2,
		CCommentdoc = 3,
		CNumber = 4,
		CWord = 5,
		CString = 6,
		CCharacter = 7,
		CUuid = 8,
		CPreprocessor = 9,
		COperator = 10,
		CIdentifier = 11,
		CStringeol = 12,
		CVerbatim = 13,
		CRegex = 14,
		CCommentlinedoc = 15,
		CWord2 = 16,
		CCommentdockeyword = 17,
		CCommentdockeyworderror = 18,
		CGlobalclass = 19,
		CStringraw = 20,
		CTripleverbatim = 21,
		CHashquotedstring = 22,
		CPreprocessorcomment = 23,
		CPreprocessorcommentdoc = 24,
		CUserliteral = 25,
		CTaskmarker = 26,
		CEscapesequence = 27,
	};

	enum TACL
	{
		CDefault = 0,
		CComment = 1,
		CCommentline = 2,
		CCommentdoc = 3,
		CNumber = 4,
		CWord = 5,
		CString = 6,
		CCharacter = 7,
		CUuid = 8,
		CPreprocessor = 9,
		COperator = 10,
		CIdentifier = 11,
		CStringeol = 12,
		CVerbatim = 13,
		CRegex = 14,
		CCommentlinedoc = 15,
		CWord2 = 16,
		CCommentdockeyword = 17,
		CCommentdockeyworderror = 18,
		CGlobalclass = 19,
		CStringraw = 20,
		CTripleverbatim = 21,
		CHashquotedstring = 22,
		CPreprocessorcomment = 23,
		CPreprocessorcommentdoc = 24,
		CUserliteral = 25,
		CTaskmarker = 26,
		CEscapesequence = 27,
	};

	enum TAL
	{
		CDefault = 0,
		CComment = 1,
		CCommentline = 2,
		CCommentdoc = 3,
		CNumber = 4,
		CWord = 5,
		CString = 6,
		CCharacter = 7,
		CUuid = 8,
		CPreprocessor = 9,
		COperator = 10,
		CIdentifier = 11,
		CStringeol = 12,
		CVerbatim = 13,
		CRegex = 14,
		CCommentlinedoc = 15,
		CWord2 = 16,
		CCommentdockeyword = 17,
		CCommentdockeyworderror = 18,
		CGlobalclass = 19,
		CStringraw = 20,
		CTripleverbatim = 21,
		CHashquotedstring = 22,
		CPreprocessorcomment = 23,
		CPreprocessorcommentdoc = 24,
		CUserliteral = 25,
		CTaskmarker = 26,
		CEscapesequence = 27,
	};

	enum COBOL
	{
		CobolDefault = 0,
		CobolComment = 1,
		CobolCommentline = 2,
		CobolCommentdoc = 3,
		CobolNumber = 4,
		CobolWord = 5,
		CobolString = 6,
		CobolCharacter = 7,
		CobolWord3 = 8,
		CobolPreprocessor = 9,
		CobolOperator = 10,
		CobolIdentifier = 11,
		CobolWord2 = 16,
	};

	enum D
	{
		DDefault = 0,
		DComment = 1,
		DCommentline = 2,
		DCommentdoc = 3,
		DCommentnested = 4,
		DNumber = 5,
		DWord = 6,
		DWord2 = 7,
		DWord3 = 8,
		DTypedef = 9,
		DString = 10,
		DStringeol = 11,
		DCharacter = 12,
		DOperator = 13,
		DIdentifier = 14,
		DCommentlinedoc = 15,
		DCommentdockeyword = 16,
		DCommentdockeyworderror = 17,
		DStringb = 18,
		DStringr = 19,
		DWord5 = 20,
		DWord6 = 21,
		DWord7 = 22,
	};

	enum TCL
	{
		TclDefault = 0,
		TclComment = 1,
		TclCommentline = 2,
		TclNumber = 3,
		TclWordInQuote = 4,
		TclInQuote = 5,
		TclOperator = 6,
		TclIdentifier = 7,
		TclSubstitution = 8,
		TclSubBrace = 9,
		TclModifier = 10,
		TclExpand = 11,
		TclWord = 12,
		TclWord2 = 13,
		TclWord3 = 14,
		TclWord4 = 15,
		TclWord5 = 16,
		TclWord6 = 17,
		TclWord7 = 18,
		TclWord8 = 19,
		TclCommentBox = 20,
		TclBlockComment = 21,
	};

	enum HTML
	{
		HDefault = 0,
		HTag = 1,
		HTagunknown = 2,
		HAttribute = 3,
		HAttributeunknown = 4,
		HNumber = 5,
		HDoublestring = 6,
		HSinglestring = 7,
		HOther = 8,
		HComment = 9,
		HEntity = 10,
		HTagend = 11,
		HXmlstart = 12,
		HXmlend = 13,
		HScript = 14,
		HAsp = 15,
		HAspat = 16,
		HCdata = 17,
		HQuestion = 18,
		HValue = 19,
		HXccomment = 20,
		HSgmlDefault = 21,
		HSgmlCommand = 22,
		HSgml1stParam = 23,
		HSgmlDoublestring = 24,
		HSgmlSimplestring = 25,
		HSgmlError = 26,
		HSgmlSpecial = 27,
		HSgmlEntity = 28,
		HSgmlComment = 29,
		HSgml1stParamComment = 30,
		HSgmlBlockDefault = 31,
		HjStart = 40,
		HjDefault = 41,
		HjComment = 42,
		HjCommentline = 43,
		HjCommentdoc = 44,
		HjNumber = 45,
		HjWord = 46,
		HjKeyword = 47,
		HjDoublestring = 48,
		HjSinglestring = 49,
		HjSymbols = 50,
		HjStringeol = 51,
		HjRegex = 52,
		HjTemplateliteral = 53,
		HjaStart = 55,
		HjaDefault = 56,
		HjaComment = 57,
		HjaCommentline = 58,
		HjaCommentdoc = 59,
		HjaNumber = 60,
		HjaWord = 61,
		HjaKeyword = 62,
		HjaDoublestring = 63,
		HjaSinglestring = 64,
		HjaSymbols = 65,
		HjaStringeol = 66,
		HjaRegex = 67,
		HjaTemplateliteral = 68,
		HbStart = 70,
		HbDefault = 71,
		HbCommentline = 72,
		HbNumber = 73,
		HbWord = 74,
		HbString = 75,
		HbIdentifier = 76,
		HbStringeol = 77,
		HbaStart = 80,
		HbaDefault = 81,
		HbaCommentline = 82,
		HbaNumber = 83,
		HbaWord = 84,
		HbaString = 85,
		HbaIdentifier = 86,
		HbaStringeol = 87,
		HpStart = 90,
		HpDefault = 91,
		HpCommentline = 92,
		HpNumber = 93,
		HpString = 94,
		HpCharacter = 95,
		HpWord = 96,
		HpTriple = 97,
		HpTripledouble = 98,
		HpClassname = 99,
		HpDefname = 100,
		HpOperator = 101,
		HpIdentifier = 102,
		HphpComplexVariable = 104,
		HpaStart = 105,
		HpaDefault = 106,
		HpaCommentline = 107,
		HpaNumber = 108,
		HpaString = 109,
		HpaCharacter = 110,
		HpaWord = 111,
		HpaTriple = 112,
		HpaTripledouble = 113,
		HpaClassname = 114,
		HpaDefname = 115,
		HpaOperator = 116,
		HpaIdentifier = 117,
		HphpDefault = 118,
		HphpHstring = 119,
		HphpSimplestring = 120,
		HphpWord = 121,
		HphpNumber = 122,
		HphpVariable = 123,
		HphpComment = 124,
		HphpCommentline = 125,
		HphpHstringVariable = 126,
		HphpOperator = 127,
	};

	enum XML
	{
		HDefault = 0,
		HTag = 1,
		HTagunknown = 2,
		HAttribute = 3,
		HAttributeunknown = 4,
		HNumber = 5,
		HDoublestring = 6,
		HSinglestring = 7,
		HOther = 8,
		HComment = 9,
		HEntity = 10,
		HTagend = 11,
		HXmlstart = 12,
		HXmlend = 13,
		HScript = 14,
		HAsp = 15,
		HAspat = 16,
		HCdata = 17,
		HQuestion = 18,
		HValue = 19,
		HXccomment = 20,
		HSgmlDefault = 21,
		HSgmlCommand = 22,
		HSgml1stParam = 23,
		HSgmlDoublestring = 24,
		HSgmlSimplestring = 25,
		HSgmlError = 26,
		HSgmlSpecial = 27,
		HSgmlEntity = 28,
		HSgmlComment = 29,
		HSgml1stParamComment = 30,
		HSgmlBlockDefault = 31,
		HjStart = 40,
		HjDefault = 41,
		HjComment = 42,
		HjCommentline = 43,
		HjCommentdoc = 44,
		HjNumber = 45,
		HjWord = 46,
		HjKeyword = 47,
		HjDoublestring = 48,
		HjSinglestring = 49,
		HjSymbols = 50,
		HjStringeol = 51,
		HjRegex = 52,
		HjTemplateliteral = 53,
		HjaStart = 55,
		HjaDefault = 56,
		HjaComment = 57,
		HjaCommentline = 58,
		HjaCommentdoc = 59,
		HjaNumber = 60,
		HjaWord = 61,
		HjaKeyword = 62,
		HjaDoublestring = 63,
		HjaSinglestring = 64,
		HjaSymbols = 65,
		HjaStringeol = 66,
		HjaRegex = 67,
		HjaTemplateliteral = 68,
		HbStart = 70,
		HbDefault = 71,
		HbCommentline = 72,
		HbNumber = 73,
		HbWord = 74,
		HbString = 75,
		HbIdentifier = 76,
		HbStringeol = 77,
		HbaStart = 80,
		HbaDefault = 81,
		HbaCommentline = 82,
		HbaNumber = 83,
		HbaWord = 84,
		HbaString = 85,
		HbaIdentifier = 86,
		HbaStringeol = 87,
		HpStart = 90,
		HpDefault = 91,
		HpCommentline = 92,
		HpNumber = 93,
		HpString = 94,
		HpCharacter = 95,
		HpWord = 96,
		HpTriple = 97,
		HpTripledouble = 98,
		HpClassname = 99,
		HpDefname = 100,
		HpOperator = 101,
		HpIdentifier = 102,
		HphpComplexVariable = 104,
		HpaStart = 105,
		HpaDefault = 106,
		HpaCommentline = 107,
		HpaNumber = 108,
		HpaString = 109,
		HpaCharacter = 110,
		HpaWord = 111,
		HpaTriple = 112,
		HpaTripledouble = 113,
		HpaClassname = 114,
		HpaDefname = 115,
		HpaOperator = 116,
		HpaIdentifier = 117,
		HphpDefault = 118,
		HphpHstring = 119,
		HphpSimplestring = 120,
		HphpWord = 121,
		HphpNumber = 122,
		HphpVariable = 123,
		HphpComment = 124,
		HphpCommentline = 125,
		HphpHstringVariable = 126,
		HphpOperator = 127,
	};

	enum Perl
	{
		PlDefault = 0,
		PlError = 1,
		PlCommentline = 2,
		PlPod = 3,
		PlNumber = 4,
		PlWord = 5,
		PlString = 6,
		PlCharacter = 7,
		PlPunctuation = 8,
		PlPreprocessor = 9,
		PlOperator = 10,
		PlIdentifier = 11,
		PlScalar = 12,
		PlArray = 13,
		PlHash = 14,
		PlSymboltable = 15,
		PlVariableIndexer = 16,
		PlRegex = 17,
		PlRegsubst = 18,
		PlLongquote = 19,
		PlBackticks = 20,
		PlDatasection = 21,
		PlHereDelim = 22,
		PlHereQ = 23,
		PlHereQq = 24,
		PlHereQx = 25,
		PlStringQ = 26,
		PlStringQq = 27,
		PlStringQx = 28,
		PlStringQr = 29,
		PlStringQw = 30,
		PlPodVerb = 31,
		PlSubPrototype = 40,
		PlFormatIdent = 41,
		PlFormat = 42,
		PlStringVar = 43,
		PlXlat = 44,
		PlRegexVar = 54,
		PlRegsubstVar = 55,
		PlBackticksVar = 57,
		PlHereQqVar = 61,
		PlHereQxVar = 62,
		PlStringQqVar = 64,
		PlStringQxVar = 65,
		PlStringQrVar = 66,
	};

	enum Ruby
	{
		RbDefault = 0,
		RbError = 1,
		RbCommentline = 2,
		RbPod = 3,
		RbNumber = 4,
		RbWord = 5,
		RbString = 6,
		RbCharacter = 7,
		RbClassname = 8,
		RbDefname = 9,
		RbOperator = 10,
		RbIdentifier = 11,
		RbRegex = 12,
		RbGlobal = 13,
		RbSymbol = 14,
		RbModuleName = 15,
		RbInstanceVar = 16,
		RbClassVar = 17,
		RbBackticks = 18,
		RbDatasection = 19,
		RbHereDelim = 20,
		RbHereQ = 21,
		RbHereQq = 22,
		RbHereQx = 23,
		RbStringQ = 24,
		RbStringQq = 25,
		RbStringQx = 26,
		RbStringQr = 27,
		RbStringQw = 28,
		RbWordDemoted = 29,
		RbStdin = 30,
		RbStdout = 31,
		RbStderr = 40,
		RbStringW = 41,
		RbStringI = 42,
		RbStringQi = 43,
		RbStringQs = 44,
		RbUpperBound = 45,
	};

	enum VB
	{
		BDefault = 0,
		BComment = 1,
		BNumber = 2,
		BKeyword = 3,
		BString = 4,
		BPreprocessor = 5,
		BOperator = 6,
		BIdentifier = 7,
		BDate = 8,
		BStringeol = 9,
		BKeyword2 = 10,
		BKeyword3 = 11,
		BKeyword4 = 12,
		BConstant = 13,
		BAsm = 14,
		BLabel = 15,
		BError = 16,
		BHexnumber = 17,
		BBinnumber = 18,
		BCommentblock = 19,
		BDocline = 20,
		BDocblock = 21,
		BDockeyword = 22,
	};

	enum VBScript
	{
		BDefault = 0,
		BComment = 1,
		BNumber = 2,
		BKeyword = 3,
		BString = 4,
		BPreprocessor = 5,
		BOperator = 6,
		BIdentifier = 7,
		BDate = 8,
		BStringeol = 9,
		BKeyword2 = 10,
		BKeyword3 = 11,
		BKeyword4 = 12,
		BConstant = 13,
		BAsm = 14,
		BLabel = 15,
		BError = 16,
		BHexnumber = 17,
		BBinnumber = 18,
		BCommentblock = 19,
		BDocline = 20,
		BDocblock = 21,
		BDockeyword = 22,
	};

	enum PowerBasic
	{
		BDefault = 0,
		BComment = 1,
		BNumber = 2,
		BKeyword = 3,
		BString = 4,
		BPreprocessor = 5,
		BOperator = 6,
		BIdentifier = 7,
		BDate = 8,
		BStringeol = 9,
		BKeyword2 = 10,
		BKeyword3 = 11,
		BKeyword4 = 12,
		BConstant = 13,
		BAsm = 14,
		BLabel = 15,
		BError = 16,
		BHexnumber = 17,
		BBinnumber = 18,
		BCommentblock = 19,
		BDocline = 20,
		BDocblock = 21,
		BDockeyword = 22,
	};

	enum BlitzBasic
	{
		BDefault = 0,
		BComment = 1,
		BNumber = 2,
		BKeyword = 3,
		BString = 4,
		BPreprocessor = 5,
		BOperator = 6,
		BIdentifier = 7,
		BDate = 8,
		BStringeol = 9,
		BKeyword2 = 10,
		BKeyword3 = 11,
		BKeyword4 = 12,
		BConstant = 13,
		BAsm = 14,
		BLabel = 15,
		BError = 16,
		BHexnumber = 17,
		BBinnumber = 18,
		BCommentblock = 19,
		BDocline = 20,
		BDocblock = 21,
		BDockeyword = 22,
	};

	enum PureBasic
	{
		BDefault = 0,
		BComment = 1,
		BNumber = 2,
		BKeyword = 3,
		BString = 4,
		BPreprocessor = 5,
		BOperator = 6,
		BIdentifier = 7,
		BDate = 8,
		BStringeol = 9,
		BKeyword2 = 10,
		BKeyword3 = 11,
		BKeyword4 = 12,
		BConstant = 13,
		BAsm = 14,
		BLabel = 15,
		BError = 16,
		BHexnumber = 17,
		BBinnumber = 18,
		BCommentblock = 19,
		BDocline = 20,
		BDocblock = 21,
		BDockeyword = 22,
	};

	enum FreeBasic
	{
		BDefault = 0,
		BComment = 1,
		BNumber = 2,
		BKeyword = 3,
		BString = 4,
		BPreprocessor = 5,
		BOperator = 6,
		BIdentifier = 7,
		BDate = 8,
		BStringeol = 9,
		BKeyword2 = 10,
		BKeyword3 = 11,
		BKeyword4 = 12,
		BConstant = 13,
		BAsm = 14,
		BLabel = 15,
		BError = 16,
		BHexnumber = 17,
		BBinnumber = 18,
		BCommentblock = 19,
		BDocline = 20,
		BDocblock = 21,
		BDockeyword = 22,
	};

	enum Properties
	{
		PropsDefault = 0,
		PropsComment = 1,
		PropsSection = 2,
		PropsAssignment = 3,
		PropsDefval = 4,
		PropsKey = 5,
	};

	enum LaTeX
	{
		LDefault = 0,
		LCommand = 1,
		LTag = 2,
		LMath = 3,
		LComment = 4,
		LTag2 = 5,
		LMath2 = 6,
		LComment2 = 7,
		LVerbatim = 8,
		LShortcmd = 9,
		LSpecial = 10,
		LCmdopt = 11,
		LError = 12,
	};

	enum Lua
	{
		LuaDefault = 0,
		LuaComment = 1,
		LuaCommentline = 2,
		LuaCommentdoc = 3,
		LuaNumber = 4,
		LuaWord = 5,
		LuaString = 6,
		LuaCharacter = 7,
		LuaLiteralstring = 8,
		LuaPreprocessor = 9,
		LuaOperator = 10,
		LuaIdentifier = 11,
		LuaStringeol = 12,
		LuaWord2 = 13,
		LuaWord3 = 14,
		LuaWord4 = 15,
		LuaWord5 = 16,
		LuaWord6 = 17,
		LuaWord7 = 18,
		LuaWord8 = 19,
		LuaLabel = 20,
	};

	enum ErrorList
	{
		ErrDefault = 0,
		ErrPython = 1,
		ErrGcc = 2,
		ErrMs = 3,
		ErrCmd = 4,
		ErrBorland = 5,
		ErrPerl = 6,
		ErrNet = 7,
		ErrLua = 8,
		ErrCtag = 9,
		ErrDiffChanged = 10,
		ErrDiffAddition = 11,
		ErrDiffDeletion = 12,
		ErrDiffMessage = 13,
		ErrPhp = 14,
		ErrElf = 15,
		ErrIfc = 16,
		ErrIfort = 17,
		ErrAbsf = 18,
		ErrTidy = 19,
		ErrJavaStack = 20,
		ErrValue = 21,
		ErrGccIncludedFrom = 22,
		ErrEscseq = 23,
		ErrEscseqUnknown = 24,
		ErrGccExcerpt = 25,
		ErrBash = 26,
		ErrEsBlack = 40,
		ErrEsRed = 41,
		ErrEsGreen = 42,
		ErrEsBrown = 43,
		ErrEsBlue = 44,
		ErrEsMagenta = 45,
		ErrEsCyan = 46,
		ErrEsGray = 47,
		ErrEsDarkGray = 48,
		ErrEsBrightRed = 49,
		ErrEsBrightGreen = 50,
		ErrEsYellow = 51,
		ErrEsBrightBlue = 52,
		ErrEsBrightMagenta = 53,
		ErrEsBrightCyan = 54,
		ErrEsWhite = 55,
	};

	enum Batch
	{
		BatDefault = 0,
		BatComment = 1,
		BatWord = 2,
		BatLabel = 3,
		BatHide = 4,
		BatCommand = 5,
		BatIdentifier = 6,
		BatOperator = 7,
		BatAfterLabel = 8,
	};

	enum TCMD
	{
		TcmdDefault = 0,
		TcmdComment = 1,
		TcmdWord = 2,
		TcmdLabel = 3,
		TcmdHide = 4,
		TcmdCommand = 5,
		TcmdIdentifier = 6,
		TcmdOperator = 7,
		TcmdEnvironment = 8,
		TcmdExpansion = 9,
		TcmdClabel = 10,
	};

	enum MakeFile
	{
		MakeDefault = 0,
		MakeComment = 1,
		MakePreprocessor = 2,
		MakeIdentifier = 3,
		MakeOperator = 4,
		MakeTarget = 5,
		MakeIdeol = 9,
	};

	enum Diff
	{
		DiffDefault = 0,
		DiffComment = 1,
		DiffCommand = 2,
		DiffHeader = 3,
		DiffPosition = 4,
		DiffDeleted = 5,
		DiffAdded = 6,
		DiffChanged = 7,
		DiffPatchAdd = 8,
		DiffPatchDelete = 9,
		DiffRemovedPatchAdd = 10,
		DiffRemovedPatchDelete = 11,
	};

	enum Conf
	{
		ConfDefault = 0,
		ConfComment = 1,
		ConfNumber = 2,
		ConfIdentifier = 3,
		ConfExtension = 4,
		ConfParameter = 5,
		ConfString = 6,
		ConfOperator = 7,
		ConfIp = 8,
		ConfDirective = 9,
	};

	enum Avenue
	{
		AveDefault = 0,
		AveComment = 1,
		AveNumber = 2,
		AveWord = 3,
		AveString = 6,
		AveEnum = 7,
		AveStringeol = 8,
		AveIdentifier = 9,
		AveOperator = 10,
		AveWord1 = 11,
		AveWord2 = 12,
		AveWord3 = 13,
		AveWord4 = 14,
		AveWord5 = 15,
		AveWord6 = 16,
	};

	enum Ada
	{
		AdaDefault = 0,
		AdaWord = 1,
		AdaIdentifier = 2,
		AdaNumber = 3,
		AdaDelimiter = 4,
		AdaCharacter = 5,
		AdaCharactereol = 6,
		AdaString = 7,
		AdaStringeol = 8,
		AdaLabel = 9,
		AdaCommentline = 10,
		AdaIllegal = 11,
	};

	enum Baan
	{
		BaanDefault = 0,
		BaanComment = 1,
		BaanCommentdoc = 2,
		BaanNumber = 3,
		BaanWord = 4,
		BaanString = 5,
		BaanPreprocessor = 6,
		BaanOperator = 7,
		BaanIdentifier = 8,
		BaanStringeol = 9,
		BaanWord2 = 10,
		BaanWord3 = 11,
		BaanWord4 = 12,
		BaanWord5 = 13,
		BaanWord6 = 14,
		BaanWord7 = 15,
		BaanWord8 = 16,
		BaanWord9 = 17,
		BaanTabledef = 18,
		BaanTablesql = 19,
		BaanFunction = 20,
		BaanDomdef = 21,
		BaanFuncdef = 22,
		BaanObjectdef = 23,
		BaanDefinedef = 24,
	};

	enum Lisp
	{
		LispDefault = 0,
		LispComment = 1,
		LispNumber = 2,
		LispKeyword = 3,
		LispKeywordKw = 4,
		LispSymbol = 5,
		LispString = 6,
		LispStringeol = 8,
		LispIdentifier = 9,
		LispOperator = 10,
		LispSpecial = 11,
		LispMultiComment = 12,
	};

	enum Eiffel
	{
		EiffelDefault = 0,
		EiffelCommentline = 1,
		EiffelNumber = 2,
		EiffelWord = 3,
		EiffelString = 4,
		EiffelCharacter = 5,
		EiffelOperator = 6,
		EiffelIdentifier = 7,
		EiffelStringeol = 8,
	};

	enum EiffelKW
	{
		EiffelDefault = 0,
		EiffelCommentline = 1,
		EiffelNumber = 2,
		EiffelWord = 3,
		EiffelString = 4,
		EiffelCharacter = 5,
		EiffelOperator = 6,
		EiffelIdentifier = 7,
		EiffelStringeol = 8,
	};

	enum NNCronTab
	{
		NncrontabDefault = 0,
		NncrontabComment = 1,
		NncrontabTask = 2,
		NncrontabSection = 3,
		NncrontabKeyword = 4,
		NncrontabModifier = 5,
		NncrontabAsterisk = 6,
		NncrontabNumber = 7,
		NncrontabString = 8,
		NncrontabEnvironment = 9,
		NncrontabIdentifier = 10,
	};

	enum Forth
	{
		ForthDefault = 0,
		ForthComment = 1,
		ForthCommentMl = 2,
		ForthIdentifier = 3,
		ForthControl = 4,
		ForthKeyword = 5,
		ForthDefword = 6,
		ForthPreword1 = 7,
		ForthPreword2 = 8,
		ForthNumber = 9,
		ForthString = 10,
		ForthLocale = 11,
	};

	enum MatLab
	{
		MatlabDefault = 0,
		MatlabComment = 1,
		MatlabCommand = 2,
		MatlabNumber = 3,
		MatlabKeyword = 4,
		MatlabString = 5,
		MatlabOperator = 6,
		MatlabIdentifier = 7,
		MatlabDoublequotestring = 8,
	};

	enum Maxima
	{
		MaximaOperator = 0,
		MaximaCommandending = 1,
		MaximaComment = 2,
		MaximaNumber = 3,
		MaximaString = 4,
		MaximaCommand = 5,
		MaximaVariable = 6,
		MaximaUnknown = 7,
	};

	enum Sol
	{
		ScriptolDefault = 0,
		ScriptolWhite = 1,
		ScriptolCommentline = 2,
		ScriptolPersistent = 3,
		ScriptolCstyle = 4,
		ScriptolCommentblock = 5,
		ScriptolNumber = 6,
		ScriptolString = 7,
		ScriptolCharacter = 8,
		ScriptolStringeol = 9,
		ScriptolKeyword = 10,
		ScriptolOperator = 11,
		ScriptolIdentifier = 12,
		ScriptolTriple = 13,
		ScriptolClassname = 14,
		ScriptolPreprocessor = 15,
	};

	enum Asm
	{
		AsmDefault = 0,
		AsmComment = 1,
		AsmNumber = 2,
		AsmString = 3,
		AsmOperator = 4,
		AsmIdentifier = 5,
		AsmCpuinstruction = 6,
		AsmMathinstruction = 7,
		AsmRegister = 8,
		AsmDirective = 9,
		AsmDirectiveoperand = 10,
		AsmCommentblock = 11,
		AsmCharacter = 12,
		AsmStringeol = 13,
		AsmExtinstruction = 14,
		AsmCommentdirective = 15,
	};

	enum As
	{
		AsmDefault = 0,
		AsmComment = 1,
		AsmNumber = 2,
		AsmString = 3,
		AsmOperator = 4,
		AsmIdentifier = 5,
		AsmCpuinstruction = 6,
		AsmMathinstruction = 7,
		AsmRegister = 8,
		AsmDirective = 9,
		AsmDirectiveoperand = 10,
		AsmCommentblock = 11,
		AsmCharacter = 12,
		AsmStringeol = 13,
		AsmExtinstruction = 14,
		AsmCommentdirective = 15,
	};

	enum Fortran
	{
		FDefault = 0,
		FComment = 1,
		FNumber = 2,
		FString1 = 3,
		FString2 = 4,
		FStringeol = 5,
		FOperator = 6,
		FIdentifier = 7,
		FWord = 8,
		FWord2 = 9,
		FWord3 = 10,
		FPreprocessor = 11,
		FOperator2 = 12,
		FLabel = 13,
		FContinuation = 14,
	};

	enum F77
	{
		FDefault = 0,
		FComment = 1,
		FNumber = 2,
		FString1 = 3,
		FString2 = 4,
		FStringeol = 5,
		FOperator = 6,
		FIdentifier = 7,
		FWord = 8,
		FWord2 = 9,
		FWord3 = 10,
		FPreprocessor = 11,
		FOperator2 = 12,
		FLabel = 13,
		FContinuation = 14,
	};

	enum CSS
	{
		CssDefault = 0,
		CssTag = 1,
		CssClass = 2,
		CssPseudoclass = 3,
		CssUnknownPseudoclass = 4,
		CssOperator = 5,
		CssIdentifier = 6,
		CssUnknownIdentifier = 7,
		CssValue = 8,
		CssComment = 9,
		CssId = 10,
		CssImportant = 11,
		CssDirective = 12,
		CssDoublestring = 13,
		CssSinglestring = 14,
		CssIdentifier2 = 15,
		CssAttribute = 16,
		CssIdentifier3 = 17,
		CssPseudoelement = 18,
		CssExtendedIdentifier = 19,
		CssExtendedPseudoclass = 20,
		CssExtendedPseudoelement = 21,
		CssGroupRule = 22,
		CssVariable = 23,
	};

	enum POV
	{
		PovDefault = 0,
		PovComment = 1,
		PovCommentline = 2,
		PovNumber = 3,
		PovOperator = 4,
		PovIdentifier = 5,
		PovString = 6,
		PovStringeol = 7,
		PovDirective = 8,
		PovBaddirective = 9,
		PovWord2 = 10,
		PovWord3 = 11,
		PovWord4 = 12,
		PovWord5 = 13,
		PovWord6 = 14,
		PovWord7 = 15,
		PovWord8 = 16,
	};

	enum LOUT
	{
		LoutDefault = 0,
		LoutComment = 1,
		LoutNumber = 2,
		LoutWord = 3,
		LoutWord2 = 4,
		LoutWord3 = 5,
		LoutWord4 = 6,
		LoutString = 7,
		LoutOperator = 8,
		LoutIdentifier = 9,
		LoutStringeol = 10,
	};

	enum ESCRIPT
	{
		EscriptDefault = 0,
		EscriptComment = 1,
		EscriptCommentline = 2,
		EscriptCommentdoc = 3,
		EscriptNumber = 4,
		EscriptWord = 5,
		EscriptString = 6,
		EscriptOperator = 7,
		EscriptIdentifier = 8,
		EscriptBrace = 9,
		EscriptWord2 = 10,
		EscriptWord3 = 11,
	};

	enum PS
	{
		PsDefault = 0,
		PsComment = 1,
		PsDscComment = 2,
		PsDscValue = 3,
		PsNumber = 4,
		PsName = 5,
		PsKeyword = 6,
		PsLiteral = 7,
		PsImmeval = 8,
		PsParenArray = 9,
		PsParenDict = 10,
		PsParenProc = 11,
		PsText = 12,
		PsHexstring = 13,
		PsBase85string = 14,
		PsBadstringchar = 15,
	};

	enum NSIS
	{
		NsisDefault = 0,
		NsisComment = 1,
		NsisStringdq = 2,
		NsisStringlq = 3,
		NsisStringrq = 4,
		NsisFunction = 5,
		NsisVariable = 6,
		NsisLabel = 7,
		NsisUserdefined = 8,
		NsisSectiondef = 9,
		NsisSubsectiondef = 10,
		NsisIfdefinedef = 11,
		NsisMacrodef = 12,
		NsisStringvar = 13,
		NsisNumber = 14,
		NsisSectiongroup = 15,
		NsisPageex = 16,
		NsisFunctiondef = 17,
		NsisCommentbox = 18,
	};

	enum MMIXAL
	{
		MmixalLeadws = 0,
		MmixalComment = 1,
		MmixalLabel = 2,
		MmixalOpcode = 3,
		MmixalOpcodePre = 4,
		MmixalOpcodeValid = 5,
		MmixalOpcodeUnknown = 6,
		MmixalOpcodePost = 7,
		MmixalOperands = 8,
		MmixalNumber = 9,
		MmixalRef = 10,
		MmixalChar = 11,
		MmixalString = 12,
		MmixalRegister = 13,
		MmixalHex = 14,
		MmixalOperator = 15,
		MmixalSymbol = 16,
		MmixalInclude = 17,
	};

	enum Clarion
	{
		ClwDefault = 0,
		ClwLabel = 1,
		ClwComment = 2,
		ClwString = 3,
		ClwUserIdentifier = 4,
		ClwIntegerConstant = 5,
		ClwRealConstant = 6,
		ClwPictureString = 7,
		ClwKeyword = 8,
		ClwCompilerDirective = 9,
		ClwRuntimeExpressions = 10,
		ClwBuiltinProceduresFunction = 11,
		ClwStructureDataType = 12,
		ClwAttribute = 13,
		ClwStandardEquate = 14,
		ClwError = 15,
		ClwDeprecated = 16,
	};

	enum LOT
	{
		LotDefault = 0,
		LotHeader = 1,
		LotBreak = 2,
		LotSet = 3,
		LotPass = 4,
		LotFail = 5,
		LotAbort = 6,
	};

	enum YAML
	{
		YamlDefault = 0,
		YamlComment = 1,
		YamlIdentifier = 2,
		YamlKeyword = 3,
		YamlNumber = 4,
		YamlReference = 5,
		YamlDocument = 6,
		YamlText = 7,
		YamlError = 8,
		YamlOperator = 9,
	};

	enum TeX
	{
		TexDefault = 0,
		TexSpecial = 1,
		TexGroup = 2,
		TexSymbol = 3,
		TexCommand = 4,
		TexText = 5,
	};

	enum Metapost
	{
		MetapostDefault = 0,
		MetapostSpecial = 1,
		MetapostGroup = 2,
		MetapostSymbol = 3,
		MetapostCommand = 4,
		MetapostText = 5,
		MetapostExtra = 6,
	};

	enum Erlang
	{
		ErlangDefault = 0,
		ErlangComment = 1,
		ErlangVariable = 2,
		ErlangNumber = 3,
		ErlangKeyword = 4,
		ErlangString = 5,
		ErlangOperator = 6,
		ErlangAtom = 7,
		ErlangFunctionName = 8,
		ErlangCharacter = 9,
		ErlangMacro = 10,
		ErlangRecord = 11,
		ErlangPreproc = 12,
		ErlangNodeName = 13,
		ErlangCommentFunction = 14,
		ErlangCommentModule = 15,
		ErlangCommentDoc = 16,
		ErlangCommentDocMacro = 17,
		ErlangAtomQuoted = 18,
		ErlangMacroQuoted = 19,
		ErlangRecordQuoted = 20,
		ErlangNodeNameQuoted = 21,
		ErlangBifs = 22,
		ErlangModules = 23,
		ErlangModulesAtt = 24,
		ErlangUnknown = 31,
	};

	enum Octave
	{
		MatlabDefault = 0,
		MatlabComment = 1,
		MatlabCommand = 2,
		MatlabNumber = 3,
		MatlabKeyword = 4,
		MatlabString = 5,
		MatlabOperator = 6,
		MatlabIdentifier = 7,
		MatlabDoublequotestring = 8,
	};

	enum Julia
	{
		JuliaDefault = 0,
		JuliaComment = 1,
		JuliaNumber = 2,
		JuliaKeyword1 = 3,
		JuliaKeyword2 = 4,
		JuliaKeyword3 = 5,
		JuliaChar = 6,
		JuliaOperator = 7,
		JuliaBracket = 8,
		JuliaIdentifier = 9,
		JuliaString = 10,
		JuliaSymbol = 11,
		JuliaMacro = 12,
		JuliaStringinterp = 13,
		JuliaDocstring = 14,
		JuliaStringliteral = 15,
		JuliaCommand = 16,
		JuliaCommandliteral = 17,
		JuliaTypeannot = 18,
		JuliaLexerror = 19,
		JuliaKeyword4 = 20,
		JuliaTypeoperator = 21,
	};

	enum MSSQL
	{
		MssqlDefault = 0,
		MssqlComment = 1,
		MssqlLineComment = 2,
		MssqlNumber = 3,
		MssqlString = 4,
		MssqlOperator = 5,
		MssqlIdentifier = 6,
		MssqlVariable = 7,
		MssqlColumnName = 8,
		MssqlStatement = 9,
		MssqlDatatype = 10,
		MssqlSystable = 11,
		MssqlGlobalVariable = 12,
		MssqlFunction = 13,
		MssqlStoredProcedure = 14,
		MssqlDefaultPrefDatatype = 15,
		MssqlColumnName2 = 16,
	};

	enum Verilog
	{
		VDefault = 0,
		VComment = 1,
		VCommentline = 2,
		VCommentlinebang = 3,
		VNumber = 4,
		VWord = 5,
		VString = 6,
		VWord2 = 7,
		VWord3 = 8,
		VPreprocessor = 9,
		VOperator = 10,
		VIdentifier = 11,
		VStringeol = 12,
		VUser = 19,
		VCommentWord = 20,
		VInput = 21,
		VOutput = 22,
		VInout = 23,
		VPortConnect = 24,
	};

	enum Kix
	{
		KixDefault = 0,
		KixComment = 1,
		KixString1 = 2,
		KixString2 = 3,
		KixNumber = 4,
		KixVar = 5,
		KixMacro = 6,
		KixKeyword = 7,
		KixFunctions = 8,
		KixOperator = 9,
		KixCommentstream = 10,
		KixIdentifier = 31,
	};

	enum Gui4Cli
	{
		GcDefault = 0,
		GcCommentline = 1,
		GcCommentblock = 2,
		GcGlobal = 3,
		GcEvent = 4,
		GcAttribute = 5,
		GcControl = 6,
		GcCommand = 7,
		GcString = 8,
		GcOperator = 9,
	};

	enum Specman
	{
		SnDefault = 0,
		SnCode = 1,
		SnCommentline = 2,
		SnCommentlinebang = 3,
		SnNumber = 4,
		SnWord = 5,
		SnString = 6,
		SnWord2 = 7,
		SnWord3 = 8,
		SnPreprocessor = 9,
		SnOperator = 10,
		SnIdentifier = 11,
		SnStringeol = 12,
		SnRegextag = 13,
		SnSignal = 14,
		SnUser = 19,
	};

	enum Au3
	{
		Au3Default = 0,
		Au3Comment = 1,
		Au3Commentblock = 2,
		Au3Number = 3,
		Au3Function = 4,
		Au3Keyword = 5,
		Au3Macro = 6,
		Au3String = 7,
		Au3Operator = 8,
		Au3Variable = 9,
		Au3Sent = 10,
		Au3Preprocessor = 11,
		Au3Special = 12,
		Au3Expand = 13,
		Au3Comobj = 14,
		Au3Udf = 15,
	};

	enum APDL
	{
		ApdlDefault = 0,
		ApdlComment = 1,
		ApdlCommentblock = 2,
		ApdlNumber = 3,
		ApdlString = 4,
		ApdlOperator = 5,
		ApdlWord = 6,
		ApdlProcessor = 7,
		ApdlCommand = 8,
		ApdlSlashcommand = 9,
		ApdlStarcommand = 10,
		ApdlArgument = 11,
		ApdlFunction = 12,
	};

	enum Bash
	{
		ShDefault = 0,
		ShError = 1,
		ShCommentline = 2,
		ShNumber = 3,
		ShWord = 4,
		ShString = 5,
		ShCharacter = 6,
		ShOperator = 7,
		ShIdentifier = 8,
		ShScalar = 9,
		ShParam = 10,
		ShBackticks = 11,
		ShHereDelim = 12,
		ShHereQ = 13,
	};

	enum Asn1
	{
		Asn1Default = 0,
		Asn1Comment = 1,
		Asn1Identifier = 2,
		Asn1String = 3,
		Asn1Oid = 4,
		Asn1Scalar = 5,
		Asn1Keyword = 6,
		Asn1Attribute = 7,
		Asn1Descriptor = 8,
		Asn1Type = 9,
		Asn1Operator = 10,
	};

	enum VHDL
	{
		VhdlDefault = 0,
		VhdlComment = 1,
		VhdlCommentlinebang = 2,
		VhdlNumber = 3,
		VhdlString = 4,
		VhdlOperator = 5,
		VhdlIdentifier = 6,
		VhdlStringeol = 7,
		VhdlKeyword = 8,
		VhdlStdoperator = 9,
		VhdlAttribute = 10,
		VhdlStdfunction = 11,
		VhdlStdpackage = 12,
		VhdlStdtype = 13,
		VhdlUserword = 14,
		VhdlBlockComment = 15,
	};

	enum Caml
	{
		CamlDefault = 0,
		CamlIdentifier = 1,
		CamlTagname = 2,
		CamlKeyword = 3,
		CamlKeyword2 = 4,
		CamlKeyword3 = 5,
		CamlLinenum = 6,
		CamlOperator = 7,
		CamlNumber = 8,
		CamlChar = 9,
		CamlWhite = 10,
		CamlString = 11,
		CamlComment = 12,
		CamlComment1 = 13,
		CamlComment2 = 14,
		CamlComment3 = 15,
	};

	enum Haskell
	{
		HaDefault = 0,
		HaIdentifier = 1,
		HaKeyword = 2,
		HaNumber = 3,
		HaString = 4,
		HaCharacter = 5,
		HaClass = 6,
		HaModule = 7,
		HaCapital = 8,
		HaData = 9,
		HaImport = 10,
		HaOperator = 11,
		HaInstance = 12,
		HaCommentline = 13,
		HaCommentblock = 14,
		HaCommentblock2 = 15,
		HaCommentblock3 = 16,
		HaPragma = 17,
		HaPreprocessor = 18,
		HaStringeol = 19,
		HaReservedOperator = 20,
		HaLiterateComment = 21,
		HaLiterateCodedelim = 22,
	};

	enum TADS3
	{
		T3Default = 0,
		T3XDefault = 1,
		T3Preprocessor = 2,
		T3BlockComment = 3,
		T3LineComment = 4,
		T3Operator = 5,
		T3Keyword = 6,
		T3Number = 7,
		T3Identifier = 8,
		T3SString = 9,
		T3DString = 10,
		T3XString = 11,
		T3LibDirective = 12,
		T3MsgParam = 13,
		T3HtmlTag = 14,
		T3HtmlDefault = 15,
		T3HtmlString = 16,
		T3User1 = 17,
		T3User2 = 18,
		T3User3 = 19,
		T3Brace = 20,
	};

	enum Rebol
	{
		RebolDefault = 0,
		RebolCommentline = 1,
		RebolCommentblock = 2,
		RebolPreface = 3,
		RebolOperator = 4,
		RebolCharacter = 5,
		RebolQuotedstring = 6,
		RebolBracedstring = 7,
		RebolNumber = 8,
		RebolPair = 9,
		RebolTuple = 10,
		RebolBinary = 11,
		RebolMoney = 12,
		RebolIssue = 13,
		RebolTag = 14,
		RebolFile = 15,
		RebolEmail = 16,
		RebolUrl = 17,
		RebolDate = 18,
		RebolTime = 19,
		RebolIdentifier = 20,
		RebolWord = 21,
		RebolWord2 = 22,
		RebolWord3 = 23,
		RebolWord4 = 24,
		RebolWord5 = 25,
		RebolWord6 = 26,
		RebolWord7 = 27,
		RebolWord8 = 28,
	};

	enum SQL
	{
		SqlDefault = 0,
		SqlComment = 1,
		SqlCommentline = 2,
		SqlCommentdoc = 3,
		SqlNumber = 4,
		SqlWord = 5,
		SqlString = 6,
		SqlCharacter = 7,
		SqlSqlplus = 8,
		SqlSqlplusPrompt = 9,
		SqlOperator = 10,
		SqlIdentifier = 11,
		SqlSqlplusComment = 13,
		SqlCommentlinedoc = 15,
		SqlWord2 = 16,
		SqlCommentdockeyword = 17,
		SqlCommentdockeyworderror = 18,
		SqlUser1 = 19,
		SqlUser2 = 20,
		SqlUser3 = 21,
		SqlUser4 = 22,
		SqlQuotedidentifier = 23,
		SqlQoperator = 24,
	};

	enum Smalltalk
	{
		StDefault = 0,
		StString = 1,
		StNumber = 2,
		StComment = 3,
		StSymbol = 4,
		StBinary = 5,
		StBool = 6,
		StSelf = 7,
		StSuper = 8,
		StNil = 9,
		StGlobal = 10,
		StReturn = 11,
		StSpecial = 12,
		StKwsend = 13,
		StAssign = 14,
		StCharacter = 15,
		StSpecSel = 16,
	};

	enum FlagShip
	{
		FsDefault = 0,
		FsComment = 1,
		FsCommentline = 2,
		FsCommentdoc = 3,
		FsCommentlinedoc = 4,
		FsCommentdockeyword = 5,
		FsCommentdockeyworderror = 6,
		FsKeyword = 7,
		FsKeyword2 = 8,
		FsKeyword3 = 9,
		FsKeyword4 = 10,
		FsNumber = 11,
		FsString = 12,
		FsPreprocessor = 13,
		FsOperator = 14,
		FsIdentifier = 15,
		FsDate = 16,
		FsStringeol = 17,
		FsConstant = 18,
		FsWordoperator = 19,
		FsDisabledcode = 20,
		FsDefaultC = 21,
		FsCommentdocC = 22,
		FsCommentlinedocC = 23,
		FsKeywordC = 24,
		FsKeyword2C = 25,
		FsNumberC = 26,
		FsStringC = 27,
		FsPreprocessorC = 28,
		FsOperatorC = 29,
		FsIdentifierC = 30,
		FsStringeolC = 31,
	};

	enum Csound
	{
		CsoundDefault = 0,
		CsoundComment = 1,
		CsoundNumber = 2,
		CsoundOperator = 3,
		CsoundInstr = 4,
		CsoundIdentifier = 5,
		CsoundOpcode = 6,
		CsoundHeaderstmt = 7,
		CsoundUserkeyword = 8,
		CsoundCommentblock = 9,
		CsoundParam = 10,
		CsoundArateVar = 11,
		CsoundKrateVar = 12,
		CsoundIrateVar = 13,
		CsoundGlobalVar = 14,
		CsoundStringeol = 15,
	};

	enum Inno
	{
		InnoDefault = 0,
		InnoComment = 1,
		InnoKeyword = 2,
		InnoParameter = 3,
		InnoSection = 4,
		InnoPreproc = 5,
		InnoInlineExpansion = 6,
		InnoCommentPascal = 7,
		InnoKeywordPascal = 8,
		InnoKeywordUser = 9,
		InnoStringDouble = 10,
		InnoStringSingle = 11,
		InnoIdentifier = 12,
	};

	enum Opal
	{
		OpalSpace = 0,
		OpalCommentBlock = 1,
		OpalCommentLine = 2,
		OpalInteger = 3,
		OpalKeyword = 4,
		OpalSort = 5,
		OpalString = 6,
		OpalPar = 7,
		OpalBoolConst = 8,
		OpalDefault = 32,
	};

	enum Spice
	{
		SpiceDefault = 0,
		SpiceIdentifier = 1,
		SpiceKeyword = 2,
		SpiceKeyword2 = 3,
		SpiceKeyword3 = 4,
		SpiceNumber = 5,
		SpiceDelimiter = 6,
		SpiceValue = 7,
		SpiceCommentline = 8,
	};

	enum CMAKE
	{
		CmakeDefault = 0,
		CmakeComment = 1,
		CmakeStringdq = 2,
		CmakeStringlq = 3,
		CmakeStringrq = 4,
		CmakeCommands = 5,
		CmakeParameters = 6,
		CmakeVariable = 7,
		CmakeUserdefined = 8,
		CmakeWhiledef = 9,
		CmakeForeachdef = 10,
		CmakeIfdefinedef = 11,
		CmakeMacrodef = 12,
		CmakeStringvar = 13,
		CmakeNumber = 14,
	};

	enum Gap
	{
		GapDefault = 0,
		GapIdentifier = 1,
		GapKeyword = 2,
		GapKeyword2 = 3,
		GapKeyword3 = 4,
		GapKeyword4 = 5,
		GapString = 6,
		GapChar = 7,
		GapOperator = 8,
		GapComment = 9,
		GapNumber = 10,
		GapStringeol = 11,
	};

	enum PLM
	{
		PlmDefault = 0,
		PlmComment = 1,
		PlmString = 2,
		PlmNumber = 3,
		PlmIdentifier = 4,
		PlmOperator = 5,
		PlmControl = 6,
		PlmKeyword = 7,
	};

	enum Progress
	{
		AblDefault = 0,
		AblNumber = 1,
		AblWord = 2,
		AblString = 3,
		AblCharacter = 4,
		AblPreprocessor = 5,
		AblOperator = 6,
		AblIdentifier = 7,
		AblBlock = 8,
		AblEnd = 9,
		AblComment = 10,
		AblTaskmarker = 11,
		AblLinecomment = 12,
	};

	enum ABAQUS
	{
		AbaqusDefault = 0,
		AbaqusComment = 1,
		AbaqusCommentblock = 2,
		AbaqusNumber = 3,
		AbaqusString = 4,
		AbaqusOperator = 5,
		AbaqusWord = 6,
		AbaqusProcessor = 7,
		AbaqusCommand = 8,
		AbaqusSlashcommand = 9,
		AbaqusStarcommand = 10,
		AbaqusArgument = 11,
		AbaqusFunction = 12,
	};

	enum Asymptote
	{
		AsyDefault = 0,
		AsyComment = 1,
		AsyCommentline = 2,
		AsyNumber = 3,
		AsyWord = 4,
		AsyString = 5,
		AsyCharacter = 6,
		AsyOperator = 7,
		AsyIdentifier = 8,
		AsyStringeol = 9,
		AsyCommentlinedoc = 10,
		AsyWord2 = 11,
	};

	enum R
	{
		RDefault = 0,
		RComment = 1,
		RKword = 2,
		RBasekword = 3,
		ROtherkword = 4,
		RNumber = 5,
		RString = 6,
		RString2 = 7,
		ROperator = 8,
		RIdentifier = 9,
		RInfix = 10,
		RInfixeol = 11,
		RBackticks = 12,
		RRawstring = 13,
		RRawstring2 = 14,
		REscapesequence = 15,
	};

	enum MagikSF
	{
		MagikDefault = 0,
		MagikComment = 1,
		MagikHyperComment = 16,
		MagikString = 2,
		MagikCharacter = 3,
		MagikNumber = 4,
		MagikIdentifier = 5,
		MagikOperator = 6,
		MagikFlow = 7,
		MagikContainer = 8,
		MagikBracketBlock = 9,
		MagikBraceBlock = 10,
		MagikSqbracketBlock = 11,
		MagikUnknownKeyword = 12,
		MagikKeyword = 13,
		MagikPragma = 14,
		MagikSymbol = 15,
	};

	enum PowerShell
	{
		PowershellDefault = 0,
		PowershellComment = 1,
		PowershellString = 2,
		PowershellCharacter = 3,
		PowershellNumber = 4,
		PowershellVariable = 5,
		PowershellOperator = 6,
		PowershellIdentifier = 7,
		PowershellKeyword = 8,
		PowershellCmdlet = 9,
		PowershellAlias = 10,
		PowershellFunction = 11,
		PowershellUser1 = 12,
		PowershellCommentstream = 13,
		PowershellHereString = 14,
		PowershellHereCharacter = 15,
		PowershellCommentdockeyword = 16,
	};

	enum MySQL
	{
		MysqlDefault = 0,
		MysqlComment = 1,
		MysqlCommentline = 2,
		MysqlVariable = 3,
		MysqlSystemvariable = 4,
		MysqlKnownsystemvariable = 5,
		MysqlNumber = 6,
		MysqlMajorkeyword = 7,
		MysqlKeyword = 8,
		MysqlDatabaseobject = 9,
		MysqlProcedurekeyword = 10,
		MysqlString = 11,
		MysqlSqstring = 12,
		MysqlDqstring = 13,
		MysqlOperator = 14,
		MysqlFunction = 15,
		MysqlIdentifier = 16,
		MysqlQuotedidentifier = 17,
		MysqlUser1 = 18,
		MysqlUser2 = 19,
		MysqlUser3 = 20,
		MysqlHiddencommand = 21,
		MysqlPlaceholder = 22,
	};

	enum Po
	{
		PoDefault = 0,
		PoComment = 1,
		PoMsgid = 2,
		PoMsgidText = 3,
		PoMsgstr = 4,
		PoMsgstrText = 5,
		PoMsgctxt = 6,
		PoMsgctxtText = 7,
		PoFuzzy = 8,
		PoProgrammerComment = 9,
		PoReference = 10,
		PoFlags = 11,
		PoMsgidTextEol = 12,
		PoMsgstrTextEol = 13,
		PoMsgctxtTextEol = 14,
		PoError = 15,
	};

	enum Pascal
	{
		PasDefault = 0,
		PasIdentifier = 1,
		PasComment = 2,
		PasComment2 = 3,
		PasCommentline = 4,
		PasPreprocessor = 5,
		PasPreprocessor2 = 6,
		PasNumber = 7,
		PasHexnumber = 8,
		PasWord = 9,
		PasString = 10,
		PasStringeol = 11,
		PasCharacter = 12,
		PasOperator = 13,
		PasAsm = 14,
	};

	enum SORCUS
	{
		SorcusDefault = 0,
		SorcusCommand = 1,
		SorcusParameter = 2,
		SorcusCommentline = 3,
		SorcusString = 4,
		SorcusStringeol = 5,
		SorcusIdentifier = 6,
		SorcusOperator = 7,
		SorcusNumber = 8,
		SorcusConstant = 9,
	};

	enum PowerPro
	{
		PowerproDefault = 0,
		PowerproCommentblock = 1,
		PowerproCommentline = 2,
		PowerproNumber = 3,
		PowerproWord = 4,
		PowerproWord2 = 5,
		PowerproWord3 = 6,
		PowerproWord4 = 7,
		PowerproDoublequotedstring = 8,
		PowerproSinglequotedstring = 9,
		PowerproLinecontinue = 10,
		PowerproOperator = 11,
		PowerproIdentifier = 12,
		PowerproStringeol = 13,
		PowerproVerbatim = 14,
		PowerproAltquote = 15,
		PowerproFunction = 16,
	};

	enum SML
	{
		SmlDefault = 0,
		SmlIdentifier = 1,
		SmlTagname = 2,
		SmlKeyword = 3,
		SmlKeyword2 = 4,
		SmlKeyword3 = 5,
		SmlLinenum = 6,
		SmlOperator = 7,
		SmlNumber = 8,
		SmlChar = 9,
		SmlString = 11,
		SmlComment = 12,
		SmlComment1 = 13,
		SmlComment2 = 14,
		SmlComment3 = 15,
	};

	enum Markdown
	{
		MarkdownDefault = 0,
		MarkdownLineBegin = 1,
		MarkdownStrong1 = 2,
		MarkdownStrong2 = 3,
		MarkdownEm1 = 4,
		MarkdownEm2 = 5,
		MarkdownHeader1 = 6,
		MarkdownHeader2 = 7,
		MarkdownHeader3 = 8,
		MarkdownHeader4 = 9,
		MarkdownHeader5 = 10,
		MarkdownHeader6 = 11,
		MarkdownPrechar = 12,
		MarkdownUlistItem = 13,
		MarkdownOlistItem = 14,
		MarkdownBlockquote = 15,
		MarkdownStrikeout = 16,
		MarkdownHrule = 17,
		MarkdownLink = 18,
		MarkdownCode = 19,
		MarkdownCode2 = 20,
		MarkdownCodebk = 21,
	};

	enum Txt2tags
	{
		Txt2tagsDefault = 0,
		Txt2tagsLineBegin = 1,
		Txt2tagsStrong1 = 2,
		Txt2tagsStrong2 = 3,
		Txt2tagsEm1 = 4,
		Txt2tagsEm2 = 5,
		Txt2tagsHeader1 = 6,
		Txt2tagsHeader2 = 7,
		Txt2tagsHeader3 = 8,
		Txt2tagsHeader4 = 9,
		Txt2tagsHeader5 = 10,
		Txt2tagsHeader6 = 11,
		Txt2tagsPrechar = 12,
		Txt2tagsUlistItem = 13,
		Txt2tagsOlistItem = 14,
		Txt2tagsBlockquote = 15,
		Txt2tagsStrikeout = 16,
		Txt2tagsHrule = 17,
		Txt2tagsLink = 18,
		Txt2tagsCode = 19,
		Txt2tagsCode2 = 20,
		Txt2tagsCodebk = 21,
		Txt2tagsComment = 22,
		Txt2tagsOption = 23,
		Txt2tagsPreproc = 24,
		Txt2tagsPostproc = 25,
	};

	enum A68k
	{
		A68kDefault = 0,
		A68kComment = 1,
		A68kNumberDec = 2,
		A68kNumberBin = 3,
		A68kNumberHex = 4,
		A68kString1 = 5,
		A68kOperator = 6,
		A68kCpuinstruction = 7,
		A68kExtinstruction = 8,
		A68kRegister = 9,
		A68kDirective = 10,
		A68kMacroArg = 11,
		A68kLabel = 12,
		A68kString2 = 13,
		A68kIdentifier = 14,
		A68kMacroDeclaration = 15,
		A68kCommentWord = 16,
		A68kCommentSpecial = 17,
		A68kCommentDoxygen = 18,
	};

	enum Modula
	{
		ModulaDefault = 0,
		ModulaComment = 1,
		ModulaDoxycomm = 2,
		ModulaDoxykey = 3,
		ModulaKeyword = 4,
		ModulaReserved = 5,
		ModulaNumber = 6,
		ModulaBasenum = 7,
		ModulaFloat = 8,
		ModulaString = 9,
		ModulaStrspec = 10,
		ModulaChar = 11,
		ModulaCharspec = 12,
		ModulaProc = 13,
		ModulaPragma = 14,
		ModulaPrgkey = 15,
		ModulaOperator = 16,
		ModulaBadstr = 17,
	};

	enum CoffeeScript
	{
		CoffeescriptDefault = 0,
		CoffeescriptComment = 1,
		CoffeescriptCommentline = 2,
		CoffeescriptCommentdoc = 3,
		CoffeescriptNumber = 4,
		CoffeescriptWord = 5,
		CoffeescriptString = 6,
		CoffeescriptCharacter = 7,
		CoffeescriptUuid = 8,
		CoffeescriptPreprocessor = 9,
		CoffeescriptOperator = 10,
		CoffeescriptIdentifier = 11,
		CoffeescriptStringeol = 12,
		CoffeescriptVerbatim = 13,
		CoffeescriptRegex = 14,
		CoffeescriptCommentlinedoc = 15,
		CoffeescriptWord2 = 16,
		CoffeescriptCommentdockeyword = 17,
		CoffeescriptCommentdockeyworderror = 18,
		CoffeescriptGlobalclass = 19,
		CoffeescriptStringraw = 20,
		CoffeescriptTripleverbatim = 21,
		CoffeescriptCommentblock = 22,
		CoffeescriptVerboseRegex = 23,
		CoffeescriptVerboseRegexComment = 24,
		CoffeescriptInstanceproperty = 25,
	};

	enum AVS
	{
		AvsDefault = 0,
		AvsCommentblock = 1,
		AvsCommentblockn = 2,
		AvsCommentline = 3,
		AvsNumber = 4,
		AvsOperator = 5,
		AvsIdentifier = 6,
		AvsString = 7,
		AvsTriplestring = 8,
		AvsKeyword = 9,
		AvsFilter = 10,
		AvsPlugin = 11,
		AvsFunction = 12,
		AvsClipprop = 13,
		AvsUserdfn = 14,
	};

	enum ECL
	{
		EclDefault = 0,
		EclComment = 1,
		EclCommentline = 2,
		EclNumber = 3,
		EclString = 4,
		EclWord0 = 5,
		EclOperator = 6,
		EclCharacter = 7,
		EclUuid = 8,
		EclPreprocessor = 9,
		EclUnknown = 10,
		EclIdentifier = 11,
		EclStringeol = 12,
		EclVerbatim = 13,
		EclRegex = 14,
		EclCommentlinedoc = 15,
		EclWord1 = 16,
		EclCommentdockeyword = 17,
		EclCommentdockeyworderror = 18,
		EclWord2 = 19,
		EclWord3 = 20,
		EclWord4 = 21,
		EclWord5 = 22,
		EclCommentdoc = 23,
		EclAdded = 24,
		EclDeleted = 25,
		EclChanged = 26,
		EclMoved = 27,
	};

	enum OScript
	{
		OscriptDefault = 0,
		OscriptLineComment = 1,
		OscriptBlockComment = 2,
		OscriptDocComment = 3,
		OscriptPreprocessor = 4,
		OscriptNumber = 5,
		OscriptSinglequoteString = 6,
		OscriptDoublequoteString = 7,
		OscriptConstant = 8,
		OscriptIdentifier = 9,
		OscriptGlobal = 10,
		OscriptKeyword = 11,
		OscriptOperator = 12,
		OscriptLabel = 13,
		OscriptType = 14,
		OscriptFunction = 15,
		OscriptObject = 16,
		OscriptProperty = 17,
		OscriptMethod = 18,
	};

	enum VisualProlog
	{
		VisualprologDefault = 0,
		VisualprologKeyMajor = 1,
		VisualprologKeyMinor = 2,
		VisualprologKeyDirective = 3,
		VisualprologCommentBlock = 4,
		VisualprologCommentLine = 5,
		VisualprologCommentKey = 6,
		VisualprologCommentKeyError = 7,
		VisualprologIdentifier = 8,
		VisualprologVariable = 9,
		VisualprologAnonymous = 10,
		VisualprologNumber = 11,
		VisualprologOperator = 12,
		VisualprologUnused1 = 13,
		VisualprologUnused2 = 14,
		VisualprologUnused3 = 15,
		VisualprologStringQuote = 16,
		VisualprologStringEscape = 17,
		VisualprologStringEscapeError = 18,
		VisualprologUnused4 = 19,
		VisualprologString = 20,
		VisualprologUnused5 = 21,
		VisualprologStringEol = 22,
		VisualprologEmbedded = 23,
		VisualprologPlaceholder = 24,
	};

	enum StructuredText
	{
		SttxtDefault = 0,
		SttxtComment = 1,
		SttxtCommentline = 2,
		SttxtKeyword = 3,
		SttxtType = 4,
		SttxtFunction = 5,
		SttxtFb = 6,
		SttxtNumber = 7,
		SttxtHexnumber = 8,
		SttxtPragma = 9,
		SttxtOperator = 10,
		SttxtCharacter = 11,
		SttxtString1 = 12,
		SttxtString2 = 13,
		SttxtStringeol = 14,
		SttxtIdentifier = 15,
		SttxtDatetime = 16,
		SttxtVars = 17,
		SttxtPragmas = 18,
	};

	enum KVIrc
	{
		KvircDefault = 0,
		KvircComment = 1,
		KvircCommentblock = 2,
		KvircString = 3,
		KvircWord = 4,
		KvircKeyword = 5,
		KvircFunctionKeyword = 6,
		KvircFunction = 7,
		KvircVariable = 8,
		KvircNumber = 9,
		KvircOperator = 10,
		KvircStringFunction = 11,
		KvircStringVariable = 12,
	};

	enum Rust
	{
		RustDefault = 0,
		RustCommentblock = 1,
		RustCommentline = 2,
		RustCommentblockdoc = 3,
		RustCommentlinedoc = 4,
		RustNumber = 5,
		RustWord = 6,
		RustWord2 = 7,
		RustWord3 = 8,
		RustWord4 = 9,
		RustWord5 = 10,
		RustWord6 = 11,
		RustWord7 = 12,
		RustString = 13,
		RustStringr = 14,
		RustCharacter = 15,
		RustOperator = 16,
		RustIdentifier = 17,
		RustLifetime = 18,
		RustMacro = 19,
		RustLexerror = 20,
		RustBytestring = 21,
		RustBytestringr = 22,
		RustBytecharacter = 23,
		RustCstring = 24,
		RustCstringr = 25,
	};

	enum DMAP
	{
		DmapDefault = 0,
		DmapComment = 1,
		DmapNumber = 2,
		DmapString1 = 3,
		DmapString2 = 4,
		DmapStringeol = 5,
		DmapOperator = 6,
		DmapIdentifier = 7,
		DmapWord = 8,
		DmapWord2 = 9,
		DmapWord3 = 10,
	};

	enum DMIS
	{
		DmisDefault = 0,
		DmisComment = 1,
		DmisString = 2,
		DmisNumber = 3,
		DmisKeyword = 4,
		DmisMajorword = 5,
		DmisMinorword = 6,
		DmisUnsupportedMajor = 7,
		DmisUnsupportedMinor = 8,
		DmisLabel = 9,
	};

	enum REG
	{
		RegDefault = 0,
		RegComment = 1,
		RegValuename = 2,
		RegString = 3,
		RegHexdigit = 4,
		RegValuetype = 5,
		RegAddedkey = 6,
		RegDeletedkey = 7,
		RegEscaped = 8,
		RegKeypathGuid = 9,
		RegStringGuid = 10,
		RegParameter = 11,
		RegOperator = 12,
	};

	enum BibTeX
	{
		BibtexDefault = 0,
		BibtexEntry = 1,
		BibtexUnknownEntry = 2,
		BibtexKey = 3,
		BibtexParameter = 4,
		BibtexValue = 5,
		BibtexComment = 6,
	};

	enum Srec
	{
		HexDefault = 0,
		HexRecstart = 1,
		HexRectype = 2,
		HexRectypeUnknown = 3,
		HexBytecount = 4,
		HexBytecountWrong = 5,
		HexNoaddress = 6,
		HexDataaddress = 7,
		HexReccount = 8,
		HexStartaddress = 9,
		HexAddressfieldUnknown = 10,
		HexExtendedaddress = 11,
		HexDataOdd = 12,
		HexDataEven = 13,
		HexDataUnknown = 14,
		HexDataEmpty = 15,
		HexChecksum = 16,
		HexChecksumWrong = 17,
		HexGarbage = 18,
	};

	enum IHex
	{
		HexDefault = 0,
		HexRecstart = 1,
		HexRectype = 2,
		HexRectypeUnknown = 3,
		HexBytecount = 4,
		HexBytecountWrong = 5,
		HexNoaddress = 6,
		HexDataaddress = 7,
		HexReccount = 8,
		HexStartaddress = 9,
		HexAddressfieldUnknown = 10,
		HexExtendedaddress = 11,
		HexDataOdd = 12,
		HexDataEven = 13,
		HexDataUnknown = 14,
		HexDataEmpty = 15,
		HexChecksum = 16,
		HexChecksumWrong = 17,
		HexGarbage = 18,
	};

	enum TEHex
	{
		HexDefault = 0,
		HexRecstart = 1,
		HexRectype = 2,
		HexRectypeUnknown = 3,
		HexBytecount = 4,
		HexBytecountWrong = 5,
		HexNoaddress = 6,
		HexDataaddress = 7,
		HexReccount = 8,
		HexStartaddress = 9,
		HexAddressfieldUnknown = 10,
		HexExtendedaddress = 11,
		HexDataOdd = 12,
		HexDataEven = 13,
		HexDataUnknown = 14,
		HexDataEmpty = 15,
		HexChecksum = 16,
		HexChecksumWrong = 17,
		HexGarbage = 18,
	};

	enum JSON
	{
		JsonDefault = 0,
		JsonNumber = 1,
		JsonString = 2,
		JsonStringeol = 3,
		JsonPropertyname = 4,
		JsonEscapesequence = 5,
		JsonLinecomment = 6,
		JsonBlockcomment = 7,
		JsonOperator = 8,
		JsonUri = 9,
		JsonCompactiri = 10,
		JsonKeyword = 11,
		JsonLdkeyword = 12,
		JsonError = 13,
	};

	enum EDIFACT
	{
		EdiDefault = 0,
		EdiSegmentstart = 1,
		EdiSegmentend = 2,
		EdiSepElement = 3,
		EdiSepComposite = 4,
		EdiSepRelease = 5,
		EdiUna = 6,
		EdiUnh = 7,
		EdiBadsegment = 8,
	};

	enum STATA
	{
		StataDefault = 0,
		StataComment = 1,
		StataCommentline = 2,
		StataCommentblock = 3,
		StataNumber = 4,
		StataOperator = 5,
		StataIdentifier = 6,
		StataString = 7,
		StataType = 8,
		StataWord = 9,
		StataGlobalMacro = 10,
		StataMacro = 11,
	};

	enum SAS
	{
		SasDefault = 0,
		SasComment = 1,
		SasCommentline = 2,
		SasCommentblock = 3,
		SasNumber = 4,
		SasOperator = 5,
		SasIdentifier = 6,
		SasString = 7,
		SasType = 8,
		SasWord = 9,
		SasGlobalMacro = 10,
		SasMacro = 11,
		SasMacroKeyword = 12,
		SasBlockKeyword = 13,
		SasMacroFunction = 14,
		SasStatement = 15,
	};

	enum Nim
	{
		NimDefault = 0,
		NimComment = 1,
		NimCommentdoc = 2,
		NimCommentline = 3,
		NimCommentlinedoc = 4,
		NimNumber = 5,
		NimString = 6,
		NimCharacter = 7,
		NimWord = 8,
		NimTriple = 9,
		NimTripledouble = 10,
		NimBackticks = 11,
		NimFuncname = 12,
		NimStringeol = 13,
		NimNumerror = 14,
		NimOperator = 15,
		NimIdentifier = 16,
	};

	enum CIL
	{
		CilDefault = 0,
		CilComment = 1,
		CilCommentline = 2,
		CilWord = 3,
		CilWord2 = 4,
		CilWord3 = 5,
		CilString = 6,
		CilLabel = 7,
		CilOperator = 8,
		CilIdentifier = 9,
		CilStringeol = 10,
	};

	enum X12
	{
		X12Default = 0,
		X12Bad = 1,
		X12Envelope = 2,
		X12Functiongroup = 3,
		X12Transactionset = 4,
		X12Segmentheader = 5,
		X12Segmentend = 6,
		X12SepElement = 7,
		X12SepSubelement = 8,
	};

	enum Dataflex
	{
		DfDefault = 0,
		DfIdentifier = 1,
		DfMetatag = 2,
		DfImage = 3,
		DfCommentline = 4,
		DfPreprocessor = 5,
		DfPreprocessor2 = 6,
		DfNumber = 7,
		DfHexnumber = 8,
		DfWord = 9,
		DfString = 10,
		DfStringeol = 11,
		DfScopeword = 12,
		DfOperator = 13,
		DfIcode = 14,
	};

	enum Hollywood
	{
		HollywoodDefault = 0,
		HollywoodComment = 1,
		HollywoodCommentblock = 2,
		HollywoodNumber = 3,
		HollywoodKeyword = 4,
		HollywoodStdapi = 5,
		HollywoodPluginapi = 6,
		HollywoodPluginmethod = 7,
		HollywoodString = 8,
		HollywoodStringblock = 9,
		HollywoodPreprocessor = 10,
		HollywoodOperator = 11,
		HollywoodIdentifier = 12,
		HollywoodConstant = 13,
		HollywoodHexnumber = 14,
	};

	enum Raku
	{
		RakuDefault = 0,
		RakuError = 1,
		RakuCommentline = 2,
		RakuCommentembed = 3,
		RakuPod = 4,
		RakuCharacter = 5,
		RakuHeredocQ = 6,
		RakuHeredocQq = 7,
		RakuString = 8,
		RakuStringQ = 9,
		RakuStringQq = 10,
		RakuStringQLang = 11,
		RakuStringVar = 12,
		RakuRegex = 13,
		RakuRegexVar = 14,
		RakuAdverb = 15,
		RakuNumber = 16,
		RakuPreprocessor = 17,
		RakuOperator = 18,
		RakuWord = 19,
		RakuFunction = 20,
		RakuIdentifier = 21,
		RakuTypedef = 22,
		RakuMu = 23,
		RakuPositional = 24,
		RakuAssociative = 25,
		RakuCallable = 26,
		RakuGrammar = 27,
		RakuClass = 28,
	};

	enum FSharp
	{
		FsharpDefault = 0,
		FsharpKeyword = 1,
		FsharpKeyword2 = 2,
		FsharpKeyword3 = 3,
		FsharpKeyword4 = 4,
		FsharpKeyword5 = 5,
		FsharpIdentifier = 6,
		FsharpQuotIdentifier = 7,
		FsharpComment = 8,
		FsharpCommentline = 9,
		FsharpPreprocessor = 10,
		FsharpLinenum = 11,
		FsharpOperator = 12,
		FsharpNumber = 13,
		FsharpCharacter = 14,
		FsharpString = 15,
		FsharpVerbatim = 16,
		FsharpQuotation = 17,
		FsharpAttribute = 18,
		FsharpFormatSpec = 19,
	};

	enum Asciidoc
	{
		AsciidocDefault = 0,
		AsciidocStrong1 = 1,
		AsciidocStrong2 = 2,
		AsciidocEm1 = 3,
		AsciidocEm2 = 4,
		AsciidocHeader1 = 5,
		AsciidocHeader2 = 6,
		AsciidocHeader3 = 7,
		AsciidocHeader4 = 8,
		AsciidocHeader5 = 9,
		AsciidocHeader6 = 10,
		AsciidocUlistItem = 11,
		AsciidocOlistItem = 12,
		AsciidocBlockquote = 13,
		AsciidocLink = 14,
		AsciidocCodebk = 15,
		AsciidocPassbk = 16,
		AsciidocComment = 17,
		AsciidocCommentbk = 18,
		AsciidocLiteral = 19,
		AsciidocLiteralbk = 20,
		AsciidocAttrib = 21,
		AsciidocAttribval = 22,
		AsciidocMacro = 23,
	};

	enum GDScript
	{
		GdDefault = 0,
		GdCommentline = 1,
		GdNumber = 2,
		GdString = 3,
		GdCharacter = 4,
		GdWord = 5,
		GdTriple = 6,
		GdTripledouble = 7,
		GdClassname = 8,
		GdFuncname = 9,
		GdOperator = 10,
		GdIdentifier = 11,
		GdCommentblock = 12,
		GdStringeol = 13,
		GdWord2 = 14,
		GdAnnotation = 15,
		GdNodepath = 16,
	};

	enum TOML
	{
		TomlDefault = 0,
		TomlComment = 1,
		TomlIdentifier = 2,
		TomlKeyword = 3,
		TomlNumber = 4,
		TomlTable = 5,
		TomlKey = 6,
		TomlError = 7,
		TomlOperator = 8,
		TomlStringSq = 9,
		TomlStringDq = 10,
		TomlTripleStringSq = 11,
		TomlTripleStringDq = 12,
		TomlEscapechar = 13,
		TomlDatetime = 14,
	};

	enum troff
	{
		TroffDefault = 0,
		TroffRequest = 1,
		TroffCommand = 2,
		TroffNumber = 3,
		TroffOperator = 4,
		TroffString = 5,
		TroffComment = 6,
		TroffIgnore = 7,
		TroffEscapeString = 8,
		TroffEscapeMacro = 9,
		TroffEscapeFont = 10,
		TroffEscapeNumber = 11,
		TroffEscapeColour = 12,
		TroffEscapeGlyph = 13,
		TroffEscapeEnv = 14,
		TroffEscapeSuppression = 15,
		TroffEscapeSize = 16,
		TroffEscapeTransparent = 17,
		TroffEscapeIsvalid = 18,
		TroffEscapeDraw = 19,
		TroffEscapeMove = 20,
		TroffEscapeHeight = 21,
		TroffEscapeOverstrike = 22,
		TroffEscapeSlant = 23,
		TroffEscapeWidth = 24,
		TroffEscapeVspacing = 25,
		TroffEscapeDevice = 26,
		TroffEscapeNomove = 27,
	};

	enum Dart
	{
		DartDefault = 0,
		DartCommentline = 1,
		DartCommentlinedoc = 2,
		DartCommentblock = 3,
		DartCommentblockdoc = 4,
		DartStringSq = 5,
		DartStringDq = 6,
		DartTripleStringSq = 7,
		DartTripleStringDq = 8,
		DartRawstringSq = 9,
		DartRawstringDq = 10,
		DartTripleRawstringSq = 11,
		DartTripleRawstringDq = 12,
		DartEscapechar = 13,
		DartIdentifier = 14,
		DartIdentifierString = 15,
		DartOperator = 16,
		DartOperatorString = 17,
		DartSymbolIdentifier = 18,
		DartSymbolOperator = 19,
		DartNumber = 20,
		DartKey = 21,
		DartMetadata = 22,
		DartKwPrimary = 23,
		DartKwSecondary = 24,
		DartKwTertiary = 25,
		DartKwType = 26,
	};

	enum Zig
	{
		ZigDefault = 0,
		ZigCommentline = 1,
		ZigCommentlinedoc = 2,
		ZigCommentlinetop = 3,
		ZigNumber = 4,
		ZigOperator = 5,
		ZigCharacter = 6,
		ZigString = 7,
		ZigMultistring = 8,
		ZigEscapechar = 9,
		ZigIdentifier = 10,
		ZigFunction = 11,
		ZigBuiltinFunction = 12,
		ZigKwPrimary = 13,
		ZigKwSecondary = 14,
		ZigKwTertiary = 15,
		ZigKwType = 16,
		ZigIdentifierString = 17,
	};

	enum Nix
	{
		NixDefault = 0,
		NixCommentline = 1,
		NixCommentblock = 2,
		NixString = 3,
		NixStringMultiline = 4,
		NixEscapechar = 5,
		NixIdentifier = 6,
		NixOperator = 7,
		NixOperatorString = 8,
		NixNumber = 9,
		NixKey = 10,
		NixPath = 11,
		NixKeyword1 = 12,
		NixKeyword2 = 13,
		NixKeyword3 = 14,
		NixKeyword4 = 15,
	};

	[default_interface]
	runtimeclass StyleNeededEventArgs
	{
		Int32 Position { get; };
	}

	[default_interface]
	runtimeclass CharAddedEventArgs
	{
		Int32 Ch { get; };
		Int32 CharacterSource { get; };
	}

	[default_interface]
	runtimeclass SavePointReachedEventArgs
	{
	}

	[default_interface]
	runtimeclass SavePointLeftEventArgs
	{
	}

	[default_interface]
	runtimeclass ModifyAttemptROEventArgs
	{
	}

	[default_interface]
	runtimeclass KeyEventArgs
	{
		Int32 Ch { get; };
		Int32 Modifiers { get; };
	}

	[default_interface]
	runtimeclass DoubleClickEventArgs
	{
		Int32 Modifiers { get; };
		Int32 Position { get; };
		Int32 Line { get; };
	}

	[default_interface]
	runtimeclass UpdateUIEventArgs
	{
		Int32 Updated { get; };
	}

	[default_interface]
	runtimeclass ModifiedEventArgs
	{
		Int32 Position { get; };
		Int32 ModificationType { get; };
		Windows.Storage.Streams.IBuffer TextAsBuffer { get; };
		String Text { get; };
		Int32 Length { get; };
		Int32 LinesAdded { get; };
		Int32 Line { get; };
		Int32 FoldLevelNow { get; };
		Int32 FoldLevelPrev { get; };
		Int32 Token { get; };
		Int32 AnnotationLinesAdded { get; };
	}

	[default_interface]
	runtimeclass MacroRecordEventArgs
	{
		Int32 Message { get; };
		Int32 WParam { get; };
		Int32 LParam { get; };
	}

	[default_interface]
	runtimeclass MarginClickEventArgs
	{
		Int32 Modifiers { get; };
		Int32 Position { get; };
		Int32 Margin { get; };
	}

	[default_interface]
	runtimeclass NeedShownEventArgs
	{
		Int32 Position { get; };
		Int32 Length { get; };
	}

	[default_interface]
	runtimeclass PaintedEventArgs
	{
	}

	[default_interface]
	runtimeclass UserListSelectionEventArgs
	{
		Int32 ListType { get; };
		Windows.Storage.Streams.IBuffer TextAsBuffer { get; };
		String Text { get; };
		Int32 Position { get; };
		Int32 Ch { get; };
		CompletionMethods ListCompletionMethod { get; };
	}

	[default_interface]
	runtimeclass URIDroppedEventArgs
	{
		Windows.Storage.Streams.IBuffer TextAsBuffer { get; };
		String Text { get; };
	}

	[default_interface]
	runtimeclass DwellStartEventArgs
	{
		Int32 Position { get; };
		Int32 X { get; };
		Int32 Y { get; };
	}

	[default_interface]
	runtimeclass DwellEndEventArgs
	{
		Int32 Position { get; };
		Int32 X { get; };
		Int32 Y { get; };
	}

	[default_interface]
	runtimeclass ZoomChangedEventArgs
	{
	}

	[default_interface]
	runtimeclass HotSpotClickEventArgs
	{
		Int32 Modifiers { get; };
		Int32 Position { get; };
	}

	[default_interface]
	runtimeclass HotSpotDoubleClickEventArgs
	{
		Int32 Modifiers { get; };
		Int32 Position { get; };
	}

	[default_interface]
	runtimeclass CallTipClickEventArgs
	{
		Int32 Position { get; };
	}

	[default_interface]
	runtimeclass AutoCSelectionEventArgs
	{
		Windows.Storage.Streams.IBuffer TextAsBuffer { get; };
		String Text { get; };
		Int32 Position { get; };
		Int32 Ch { get; };
		CompletionMethods ListCompletionMethod { get; };
	}

	[default_interface]
	runtimeclass IndicatorClickEventArgs
	{
		Int32 Modifiers { get; };
		Int32 Position { get; };
	}

	[default_interface]
	runtimeclass IndicatorReleaseEventArgs
	{
		Int32 Modifiers { get; };
		Int32 Position { get; };
	}

	[default_interface]
	runtimeclass AutoCCancelledEventArgs
	{
	}

	[default_interface]
	runtimeclass AutoCCharDeletedEventArgs
	{
	}

	[default_interface]
	runtimeclass HotSpotReleaseClickEventArgs
	{
		Int32 Modifiers { get; };
		Int32 Position { get; };
	}

	[default_interface]
	runtimeclass FocusInEventArgs
	{
	}

	[default_interface]
	runtimeclass FocusOutEventArgs
	{
	}

	[default_interface]
	runtimeclass AutoCCompletedEventArgs
	{
		Windows.Storage.Streams.IBuffer TextAsBuffer { get; };
		String Text { get; };
		Int32 Position { get; };
		Int32 Ch { get; };
		CompletionMethods ListCompletionMethod { get; };
	}

	[default_interface]
	runtimeclass MarginRightClickEventArgs
	{
		Int32 Modifiers { get; };
		Int32 Position { get; };
		Int32 Margin { get; };
	}

	[default_interface]
	runtimeclass AutoCSelectionChangeEventArgs
	{
		Int32 ListType { get; };
		Windows.Storage.Streams.IBuffer TextAsBuffer { get; };
		String Text { get; };
		Int32 Position { get; };
	}

	delegate void StyleNeededHandler(Editor sender, StyleNeededEventArgs args);
	delegate void CharAddedHandler(Editor sender, CharAddedEventArgs args);
	delegate void SavePointReachedHandler(Editor sender, SavePointReachedEventArgs args);
	delegate void SavePointLeftHandler(Editor sender, SavePointLeftEventArgs args);
	delegate void ModifyAttemptROHandler(Editor sender, ModifyAttemptROEventArgs args);
	delegate void KeyHandler(Editor sender, KeyEventArgs args);
	delegate void DoubleClickHandler(Editor sender, DoubleClickEventArgs args);
	delegate void UpdateUIHandler(Editor sender, UpdateUIEventArgs args);
	delegate void ModifiedHandler(Editor sender, ModifiedEventArgs args);
	delegate void MacroRecordHandler(Editor sender, MacroRecordEventArgs args);
	delegate void MarginClickHandler(Editor sender, MarginClickEventArgs args);
	delegate void NeedShownHandler(Editor sender, NeedShownEventArgs args);
	delegate void PaintedHandler(Editor sender, PaintedEventArgs args);
	delegate void UserListSelectionHandler(Editor sender, UserListSelectionEventArgs args);
	delegate void URIDroppedHandler(Editor sender, URIDroppedEventArgs args);
	delegate void DwellStartHandler(Editor sender, DwellStartEventArgs args);
	delegate void DwellEndHandler(Editor sender, DwellEndEventArgs args);
	delegate void ZoomChangedHandler(Editor sender, ZoomChangedEventArgs args);
	delegate void HotSpotClickHandler(Editor sender, HotSpotClickEventArgs args);
	delegate void HotSpotDoubleClickHandler(Editor sender, HotSpotDoubleClickEventArgs args);
	delegate void CallTipClickHandler(Editor sender, CallTipClickEventArgs args);
	delegate void AutoCSelectionHandler(Editor sender, AutoCSelectionEventArgs args);
	delegate void IndicatorClickHandler(Editor sender, IndicatorClickEventArgs args);
	delegate void IndicatorReleaseHandler(Editor sender, IndicatorReleaseEventArgs args);
	delegate void AutoCCancelledHandler(Editor sender, AutoCCancelledEventArgs args);
	delegate void AutoCCharDeletedHandler(Editor sender, AutoCCharDeletedEventArgs args);
	delegate void HotSpotReleaseClickHandler(Editor sender, HotSpotReleaseClickEventArgs args);
	delegate void FocusInHandler(Editor sender, FocusInEventArgs args);
	delegate void FocusOutHandler(Editor sender, FocusOutEventArgs args);
	delegate void AutoCCompletedHandler(Editor sender, AutoCCompletedEventArgs args);
	delegate void MarginRightClickHandler(Editor sender, MarginRightClickEventArgs args);
	delegate void AutoCSelectionChangeHandler(Editor sender, AutoCSelectionChangeEventArgs args);

	[default_interface]
	runtimeclass Editor
	{
		event StyleNeededHandler StyleNeeded;
		event CharAddedHandler CharAdded;
		event SavePointReachedHandler SavePointReached;
		event SavePointLeftHandler SavePointLeft;
		event ModifyAttemptROHandler ModifyAttemptRO;
		event KeyHandler Key;
		event DoubleClickHandler DoubleClick;
		event UpdateUIHandler UpdateUI;
		event ModifiedHandler Modified;
		event MacroRecordHandler MacroRecord;
		event MarginClickHandler MarginClick;
		event NeedShownHandler NeedShown;
		event PaintedHandler Painted;
		event UserListSelectionHandler UserListSelection;
		event URIDroppedHandler URIDropped;
		event DwellStartHandler DwellStart;
		event DwellEndHandler DwellEnd;
		event ZoomChangedHandler ZoomChanged;
		event HotSpotClickHandler HotSpotClick;
		event HotSpotDoubleClickHandler HotSpotDoubleClick;
		event CallTipClickHandler CallTipClick;
		event AutoCSelectionHandler AutoCSelection;
		event IndicatorClickHandler IndicatorClick;
		event IndicatorReleaseHandler IndicatorRelease;
		event AutoCCancelledHandler AutoCCancelled;
		event AutoCCharDeletedHandler AutoCCharDeleted;
		event HotSpotReleaseClickHandler HotSpotReleaseClick;
		event FocusInHandler FocusIn;
		event FocusOutHandler FocusOut;
		event AutoCCompletedHandler AutoCCompleted;
		event MarginRightClickHandler MarginRightClick;
		event AutoCSelectionChangeHandler AutoCSelectionChange;

		/**
		 * Returns the number of bytes in the document.
		 */
		Int64 Length { get; };

		/**
		 * Returns the position of the caret.
		 * Sets the position of the caret.
		 */
		Int64 CurrentPos { get; set; };

		/**
		 * Returns the position of the opposite end of the selection to the caret.
		 * Set the selection anchor to a position. The anchor is the opposite
		 * end of the selection from the caret.
		 */
		Int64 Anchor { get; set; };

		/**
		 * Is undo history being collected?
		 * Choose between collecting actions into the undo
		 * history and discarding them.
		 */
		Boolean UndoCollection { get; set; };

		/**
		 * Are white space characters currently visible?
		 * Returns one of SCWS_* constants.
		 * Make white space characters invisible, always visible or visible outside indentation.
		 */
		WhiteSpace ViewWS { get; set; };

		/**
		 * Retrieve the current tab draw mode.
		 * Returns one of SCTD_* constants.
		 * Set how tabs are drawn when visible.
		 */
		TabDrawMode TabDrawMode { get; set; };

		/**
		 * Retrieve the position of the last correctly styled character.
		 */
		Int64 EndStyled { get; };

		/**
		 * Retrieve the current end of line mode - one of CRLF, CR, or LF.
		 * Set the current end of line mode.
		 */
		EndOfLine EOLMode { get; set; };

		/**
		 * Is drawing done first into a buffer or direct to the screen?
		 * If drawing is buffered then each line of text is drawn into a bitmap buffer
		 * before drawing it to the screen to avoid flicker.
		 */
		Boolean BufferedDraw { get; set; };

		/**
		 * Retrieve the visible size of a tab.
		 * Change the visible size of a tab to be a multiple of the width of a space character.
		 */
		Int32 TabWidth { get; set; };

		/**
		 * Get the minimum visual width of a tab.
		 * Set the minimum visual width of a tab.
		 */
		Int32 TabMinimumWidth { get; set; };

		/**
		 * Is the IME displayed in a window or inline?
		 * Choose to display the IME in a window or inline.
		 */
		IMEInteraction IMEInteraction { get; set; };

		/**
		 * How many margins are there?.
		 * Allocate a non-standard number of margins.
		 */
		Int32 Margins { get; set; };

		/**
		 * Get the alpha of the selection.
		 * Set the alpha of the selection.
		 */
		Alpha SelAlpha { get; set; };

		/**
		 * Is the selection end of line filled?
		 * Set the selection to have its end of line filled or not.
		 */
		Boolean SelEOLFilled { get; set; };

		/**
		 * Get the layer for drawing selections
		 * Set the layer for drawing selections: either opaquely on base layer or translucently over text
		 */
		Layer SelectionLayer { get; set; };

		/**
		 * Get the layer of the background of the line containing the caret.
		 * Set the layer of the background of the line containing the caret.
		 */
		Layer CaretLineLayer { get; set; };

		/**
		 * Get only highlighting subline instead of whole line.
		 * Set only highlighting subline instead of whole line.
		 */
		Boolean CaretLineHighlightSubLine { get; set; };

		/**
		 * Get the time in milliseconds that the caret is on and off.
		 * Get the time in milliseconds that the caret is on and off. 0 = steady on.
		 */
		Int32 CaretPeriod { get; set; };

		/**
		 * Get the number of characters to have directly indexed categories
		 * Set the number of characters to have directly indexed categories
		 */
		Int32 CharacterCategoryOptimization { get; set; };

		/**
		 * Is an undo sequence active?
		 */
		Int32 UndoSequence { get; };

		/**
		 * How many undo actions are in the history?
		 */
		Int32 UndoActions { get; };

		/**
		 * Which action is the save point?
		 * Set action as the save point
		 */
		Int32 UndoSavePoint { get; set; };

		/**
		 * Which action is the detach point?
		 * Set action as the detach point
		 */
		Int32 UndoDetach { get; set; };

		/**
		 * Which action is the tentative point?
		 * Set action as the tentative point
		 */
		Int32 UndoTentative { get; set; };

		/**
		 * Which action is the current point?
		 * Set action as the current point
		 */
		Int32 UndoCurrent { get; set; };

		/**
		 * Get the size of the dots used to mark space characters.
		 * Set the size of the dots used to mark space characters.
		 */
		Int32 WhitespaceSize { get; set; };

		/**
		 * Retrieve the last line number that has line state.
		 */
		Int32 MaxLineState { get; };

		/**
		 * Is the background of the line containing the caret in a different colour?
		 * Display the background of the line containing the caret in a different colour.
		 */
		Boolean CaretLineVisible { get; set; };

		/**
		 * Get the colour of the background of the line containing the caret.
		 * Set the colour of the background of the line containing the caret.
		 */
		Int32 CaretLineBack { get; set; };

		/**
		 * Retrieve the caret line frame width.
		 * Width = 0 means this option is disabled.
		 * Display the caret line framed.
		 * Set width != 0 to enable this option and width = 0 to disable it.
		 */
		Int32 CaretLineFrame { get; set; };

		/**
		 * Retrieve the auto-completion list separator character.
		 * Change the separator character in the string setting up an auto-completion list.
		 * Default is space but can be changed if items contain space.
		 */
		Int32 AutoCSeparator { get; set; };

		/**
		 * Retrieve whether auto-completion cancelled by backspacing before start.
		 * Should the auto-completion list be cancelled if the user backspaces to a
		 * position before where the box was created.
		 */
		Boolean AutoCCancelAtStart { get; set; };

		/**
		 * Retrieve whether a single item auto-completion list automatically choose the item.
		 * Should a single item auto-completion list automatically choose the item.
		 */
		Boolean AutoCChooseSingle { get; set; };

		/**
		 * Retrieve state of ignore case flag.
		 * Set whether case is significant when performing auto-completion searches.
		 */
		Boolean AutoCIgnoreCase { get; set; };

		/**
		 * Retrieve whether or not autocompletion is hidden automatically when nothing matches.
		 * Set whether or not autocompletion is hidden automatically when nothing matches.
		 */
		Boolean AutoCAutoHide { get; set; };

		/**
		 * Retrieve autocompletion options.
		 * Set autocompletion options.
		 */
		AutoCompleteOption AutoCOptions { get; set; };

		/**
		 * Retrieve whether or not autocompletion deletes any word characters
		 * after the inserted text upon completion.
		 * Set whether or not autocompletion deletes any word characters
		 * after the inserted text upon completion.
		 */
		Boolean AutoCDropRestOfWord { get; set; };

		/**
		 * Retrieve the auto-completion list type-separator character.
		 * Change the type-separator character in the string setting up an auto-completion list.
		 * Default is '?' but can be changed if items contain '?'.
		 */
		Int32 AutoCTypeSeparator { get; set; };

		/**
		 * Get the maximum width, in characters, of auto-completion and user lists.
		 * Set the maximum width, in characters, of auto-completion and user lists.
		 * Set to 0 to autosize to fit longest item, which is the default.
		 */
		Int32 AutoCMaxWidth { get; set; };

		/**
		 * Set the maximum height, in rows, of auto-completion and user lists.
		 * Set the maximum height, in rows, of auto-completion and user lists.
		 * The default is 5 rows.
		 */
		Int32 AutoCMaxHeight { get; set; };

		/**
		 * Get the style number used for auto-completion and user lists fonts.
		 * Set the style number used for auto-completion and user lists fonts.
		 */
		Int32 AutoCStyle { get; set; };

		/**
		 * Retrieve indentation size.
		 * Set the number of spaces used for one level of indentation.
		 */
		Int32 Indent { get; set; };

		/**
		 * Retrieve whether tabs will be used in indentation.
		 * Indentation will only use space characters if useTabs is false, otherwise
		 * it will use a combination of tabs and spaces.
		 */
		Boolean UseTabs { get; set; };

		/**
		 * Is the horizontal scroll bar visible?
		 * Show or hide the horizontal scroll bar.
		 */
		Boolean HScrollBar { get; set; };

		/**
		 * Are the indentation guides visible?
		 * Show or hide indentation guides.
		 */
		IndentView IndentationGuides { get; set; };

		/**
		 * Get the highlighted indentation guide column.
		 * Set the highlighted indentation guide column.
		 * 0 = no highlighted guide.
		 */
		Int64 HighlightGuide { get; set; };

		/**
		 * Get the code page used to interpret the bytes of the document as characters.
		 * Set the code page used to interpret the bytes of the document as characters.
		 * The SC_CP_UTF8 value can be used to enter Unicode mode.
		 */
		Int32 CodePage { get; set; };

		/**
		 * Get the foreground colour of the caret.
		 * Set the foreground colour of the caret.
		 */
		Int32 CaretFore { get; set; };

		/**
		 * In read-only mode?
		 * Set to read only or read write.
		 */
		Boolean ReadOnly { get; set; };

		/**
		 * Returns the position at the start of the selection.
		 * Sets the position that starts the selection - this becomes the anchor.
		 */
		Int64 SelectionStart { get; set; };

		/**
		 * Returns the position at the end of the selection.
		 * Sets the position that ends the selection - this becomes the caret.
		 */
		Int64 SelectionEnd { get; set; };

		/**
		 * Returns the print magnification.
		 * Sets the print magnification added to the point size of each style for printing.
		 */
		Int32 PrintMagnification { get; set; };

		/**
		 * Returns the print colour mode.
		 * Modify colours when printing for clearer printed text.
		 */
		PrintOption PrintColourMode { get; set; };

		/**
		 * Report change history status.
		 * Enable or disable change history.
		 */
		ChangeHistoryOption ChangeHistory { get; set; };

		/**
		 * Retrieve the display line at the top of the display.
		 * Scroll so that a display line is at the top of the display.
		 */
		Int64 FirstVisibleLine { get; set; };

		/**
		 * Returns the number of lines in the document. There is always at least one.
		 */
		Int64 LineCount { get; };

		/**
		 * Returns the size in pixels of the left margin.
		 * Sets the size in pixels of the left margin.
		 */
		Int32 MarginLeft { get; set; };

		/**
		 * Returns the size in pixels of the right margin.
		 * Sets the size in pixels of the right margin.
		 */
		Int32 MarginRight { get; set; };

		/**
		 * Is the document different from when it was last saved?
		 */
		Boolean Modify { get; };

		Boolean SelectionHidden { get; };

		/**
		 * Retrieve the number of characters in the document.
		 */
		Int64 TextLength { get; };

		/**
		 * Retrieve a pointer to a function that processes messages for this Scintilla.
		 */
		UInt64 DirectFunction { get; };

		/**
		 * Retrieve a pointer to a function that processes messages for this Scintilla and returns status.
		 */
		UInt64 DirectStatusFunction { get; };

		/**
		 * Retrieve a pointer value to use as the first argument when calling
		 * the function returned by GetDirectFunction.
		 */
		UInt64 DirectPointer { get; };

		/**
		 * Returns true if overtype mode is active otherwise false is returned.
		 * Set to overtype (true) or insert mode.
		 */
		Boolean Overtype { get; set; };

		/**
		 * Returns the width of the insert mode caret.
		 * Set the width of the insert mode caret.
		 */
		Int32 CaretWidth { get; set; };

		/**
		 * Get the position that starts the target.
		 * Sets the position that starts the target which is used for updating the
		 * document without affecting the scroll position.
		 */
		Int64 TargetStart { get; set; };

		/**
		 * Get the virtual space of the target start
		 * Sets the virtual space of the target start
		 */
		Int64 TargetStartVirtualSpace { get; set; };

		/**
		 * Get the position that ends the target.
		 * Sets the position that ends the target which is used for updating the
		 * document without affecting the scroll position.
		 */
		Int64 TargetEnd { get; set; };

		/**
		 * Get the virtual space of the target end
		 * Sets the virtual space of the target end
		 */
		Int64 TargetEndVirtualSpace { get; set; };

		/**
		 * Get the search flags used by SearchInTarget.
		 * Set the search flags used by SearchInTarget.
		 */
		FindOption SearchFlags { get; set; };

		/**
		 * Are all lines visible?
		 */
		Boolean AllLinesVisible { get; };

		/**
		 * Get the style of fold display text.
		 * Set the style of fold display text.
		 */
		FoldDisplayTextStyle FoldDisplayTextStyle { get; set; };

		/**
		 * Get automatic folding behaviours.
		 * Set automatic folding behaviours.
		 */
		AutomaticFold AutomaticFold { get; set; };

		/**
		 * Does a tab pressed when caret is within indentation indent?
		 * Sets whether a tab pressed when caret is within indentation indents.
		 */
		Boolean TabIndents { get; set; };

		/**
		 * Does a backspace pressed when caret is within indentation unindent?
		 * Sets whether a backspace pressed when caret is within indentation unindents.
		 */
		Boolean BackSpaceUnIndents { get; set; };

		/**
		 * Retrieve the time the mouse must sit still to generate a mouse dwell event.
		 * Sets the time the mouse must sit still to generate a mouse dwell event.
		 */
		Int32 MouseDwellTime { get; set; };

		/**
		 * Retrieve the limits to idle styling.
		 * Sets limits to idle styling.
		 */
		IdleStyling IdleStyling { get; set; };

		/**
		 * Retrieve whether text is word wrapped.
		 * Sets whether text is word wrapped.
		 */
		Wrap WrapMode { get; set; };

		/**
		 * Retrive the display mode of visual flags for wrapped lines.
		 * Set the display mode of visual flags for wrapped lines.
		 */
		WrapVisualFlag WrapVisualFlags { get; set; };

		/**
		 * Retrive the location of visual flags for wrapped lines.
		 * Set the location of visual flags for wrapped lines.
		 */
		WrapVisualLocation WrapVisualFlagsLocation { get; set; };

		/**
		 * Retrive the start indent for wrapped lines.
		 * Set the start indent for wrapped lines.
		 */
		Int32 WrapStartIndent { get; set; };

		/**
		 * Retrieve how wrapped sublines are placed. Default is fixed.
		 * Sets how wrapped sublines are placed. Default is fixed.
		 */
		WrapIndentMode WrapIndentMode { get; set; };

		/**
		 * Retrieve the degree of caching of layout information.
		 * Sets the degree of caching of layout information.
		 */
		LineCache LayoutCache { get; set; };

		/**
		 * Retrieve the document width assumed for scrolling.
		 * Sets the document width assumed for scrolling.
		 */
		Int32 ScrollWidth { get; set; };

		/**
		 * Retrieve whether the scroll width tracks wide lines.
		 * Sets whether the maximum width line displayed is used to set scroll width.
		 */
		Boolean ScrollWidthTracking { get; set; };

		/**
		 * Retrieve whether the maximum scroll position has the last
		 * line at the bottom of the view.
		 * Sets the scroll range so that maximum scroll position has
		 * the last line at the bottom of the view (default).
		 * Setting this to false allows scrolling one page below the last line.
		 */
		Boolean EndAtLastLine { get; set; };

		/**
		 * Is the vertical scroll bar visible?
		 * Show or hide the vertical scroll bar.
		 */
		Boolean VScrollBar { get; set; };

		/**
		 * How many phases is drawing done in?
		 * In one phase draw, text is drawn in a series of rectangular blocks with no overlap.
		 * In two phase draw, text is drawn in a series of lines allowing runs to overlap horizontally.
		 * In multiple phase draw, each element is drawn over the whole drawing area, allowing text
		 * to overlap from one line to the next.
		 */
		PhasesDraw PhasesDraw { get; set; };

		/**
		 * Retrieve the quality level for text.
		 * Choose the quality level for text from the FontQuality enumeration.
		 */
		FontQuality FontQuality { get; set; };

		/**
		 * Retrieve the effect of pasting when there are multiple selections.
		 * Change the effect of pasting when there are multiple selections.
		 */
		MultiPaste MultiPaste { get; set; };

		/**
		 * Report accessibility status.
		 * Enable or disable accessibility.
		 */
		Accessibility Accessibility { get; set; };

		/**
		 * Are the end of line characters visible?
		 * Make the end of line characters visible or invisible.
		 */
		Boolean ViewEOL { get; set; };

		/**
		 * Retrieve a pointer to the document object.
		 * Change the document object used.
		 */
		UInt64 DocPointer { get; set; };

		/**
		 * Retrieve the column number which text should be kept within.
		 * Set the column number of the edge.
		 * If text goes past the edge then it is highlighted.
		 */
		Int64 EdgeColumn { get; set; };

		/**
		 * Retrieve the edge highlight mode.
		 * The edge may be displayed by a line (EDGE_LINE/EDGE_MULTILINE) or by highlighting text that
		 * goes beyond it (EDGE_BACKGROUND) or not displayed at all (EDGE_NONE).
		 */
		EdgeVisualStyle EdgeMode { get; set; };

		/**
		 * Retrieve the colour used in edge indication.
		 * Change the colour used in edge indication.
		 */
		Int32 EdgeColour { get; set; };

		/**
		 * Retrieves the number of lines completely visible.
		 */
		Int64 LinesOnScreen { get; };

		/**
		 * Is the selection rectangular? The alternative is the more common stream selection.
		 */
		Boolean SelectionIsRectangle { get; };

		/**
		 * Retrieve the zoom level.
		 * Set the zoom level. This number of points is added to the size of all fonts.
		 * It may be positive to magnify or negative to reduce.
		 */
		Int32 Zoom { get; set; };

		/**
		 * Get which document options are set.
		 */
		DocumentOption DocumentOptions { get; };

		/**
		 * Get which document modification events are sent to the container.
		 * Set which document modification events are sent to the container.
		 */
		ModificationFlags ModEventMask { get; set; };

		/**
		 * Get whether command events are sent to the container.
		 * Set whether command events are sent to the container.
		 */
		Boolean CommandEvents { get; set; };

		/**
		 * Get internal focus flag.
		 * Change internal focus flag.
		 */
		Boolean Focus { get; set; };

		/**
		 * Get error status.
		 * Change error status - 0 = OK.
		 */
		Status Status { get; set; };

		/**
		 * Get whether mouse gets captured.
		 * Set whether the mouse is captured when its button is pressed.
		 */
		Boolean MouseDownCaptures { get; set; };

		/**
		 * Get whether mouse wheel can be active outside the window.
		 * Set whether the mouse wheel can be active outside the window.
		 */
		Boolean MouseWheelCaptures { get; set; };

		/**
		 * Get cursor type.
		 * Sets the cursor to one of the SC_CURSOR* values.
		 */
		CursorShape Cursor { get; set; };

		/**
		 * Get the way control characters are displayed.
		 * Change the way control characters are displayed:
		 * If symbol is < 32, keep the drawn way, else, use the given character.
		 */
		Int32 ControlCharSymbol { get; set; };

		/**
		 * Get the xOffset (ie, horizontal scroll position).
		 * Set the xOffset (ie, horizontal scroll position).
		 */
		Int32 XOffset { get; set; };

		/**
		 * Is printing line wrapped?
		 * Set printing to line wrapped (SC_WRAP_WORD) or not line wrapped (SC_WRAP_NONE).
		 */
		Wrap PrintWrapMode { get; set; };

		/**
		 * Get whether underlining for active hotspots.
		 * Enable / Disable underlining active hotspots.
		 */
		Boolean HotspotActiveUnderline { get; set; };

		/**
		 * Get the HotspotSingleLine property
		 * Limit hotspots to single line so hotspots on two lines don't merge.
		 */
		Boolean HotspotSingleLine { get; set; };

		/**
		 * Get the mode of the current selection.
		 * Set the selection mode to stream (SC_SEL_STREAM) or rectangular (SC_SEL_RECTANGLE/SC_SEL_THIN) or
		 * by lines (SC_SEL_LINES).
		 */
		SelectionMode SelectionMode { get; set; };

		/**
		 * Get whether or not regular caret moves will extend or reduce the selection.
		 * Set whether or not regular caret moves will extend or reduce the selection.
		 */
		Boolean MoveExtendsSelection { get; set; };

		/**
		 * Get currently selected item position in the auto-completion list
		 */
		Int32 AutoCCurrent { get; };

		/**
		 * Get auto-completion case insensitive behaviour.
		 * Set auto-completion case insensitive behaviour to either prefer case-sensitive matches or have no preference.
		 */
		CaseInsensitiveBehaviour AutoCCaseInsensitiveBehaviour { get; set; };

		/**
		 * Retrieve the effect of autocompleting when there are multiple selections.
		 * Change the effect of autocompleting when there are multiple selections.
		 */
		MultiAutoComplete AutoCMulti { get; set; };

		/**
		 * Get the way autocompletion lists are ordered.
		 * Set the way autocompletion lists are ordered.
		 */
		Ordering AutoCOrder { get; set; };

		/**
		 * Can the caret preferred x position only be changed by explicit movement commands?
		 * Stop the caret preferred x position changing when the user types.
		 */
		CaretSticky CaretSticky { get; set; };

		/**
		 * Get convert-on-paste setting
		 * Enable/Disable convert-on-paste for line endings
		 */
		Boolean PasteConvertEndings { get; set; };

		/**
		 * Get the background alpha of the caret line.
		 * Set background alpha of the caret line.
		 */
		Alpha CaretLineBackAlpha { get; set; };

		/**
		 * Returns the current style of the caret.
		 * Set the style of the caret to be drawn.
		 */
		CaretStyle CaretStyle { get; set; };

		/**
		 * Get the current indicator
		 * Set the indicator used for IndicatorFillRange and IndicatorClearRange
		 */
		Int32 IndicatorCurrent { get; set; };

		/**
		 * Get the current indicator value
		 * Set the value used for IndicatorFillRange
		 */
		Int32 IndicatorValue { get; set; };

		/**
		 * How many entries are allocated to the position cache?
		 * Set number of entries in position cache
		 */
		Int32 PositionCache { get; set; };

		/**
		 * Get maximum number of threads used for layout
		 * Set maximum number of threads used for layout
		 */
		Int32 LayoutThreads { get; set; };

		/**
		 * Compact the document buffer and return a read-only pointer to the
		 * characters in the document.
		 */
		UInt64 CharacterPointer { get; };

		/**
		 * Return a position which, to avoid performance costs, should not be within
		 * the range of a call to GetRangePointer.
		 */
		Int64 GapPosition { get; };

		/**
		 * Get extra ascent for each line
		 * Set extra ascent for each line
		 */
		Int32 ExtraAscent { get; set; };

		/**
		 * Get extra descent for each line
		 * Set extra descent for each line
		 */
		Int32 ExtraDescent { get; set; };

		/**
		 * Get the start of the range of style numbers used for margin text
		 * Get the start of the range of style numbers used for margin text
		 */
		Int32 MarginStyleOffset { get; set; };

		/**
		 * Get the margin options.
		 * Set the margin options.
		 */
		MarginOption MarginOptions { get; set; };

		/**
		 * Get the visibility for the annotations for a view
		 * Set the visibility for the annotations for a view
		 */
		AnnotationVisible AnnotationVisible { get; set; };

		/**
		 * Get the start of the range of style numbers used for annotations
		 * Get the start of the range of style numbers used for annotations
		 */
		Int32 AnnotationStyleOffset { get; set; };

		/**
		 * Whether switching to rectangular mode while selecting with the mouse is allowed.
		 * Set whether switching to rectangular mode while selecting with the mouse is allowed.
		 */
		Boolean MouseSelectionRectangularSwitch { get; set; };

		/**
		 * Whether multiple selections can be made
		 * Set whether multiple selections can be made
		 */
		Boolean MultipleSelection { get; set; };

		/**
		 * Whether typing can be performed into multiple selections
		 * Set whether typing can be performed into multiple selections
		 */
		Boolean AdditionalSelectionTyping { get; set; };

		/**
		 * Whether additional carets will blink
		 * Set whether additional carets will blink
		 */
		Boolean AdditionalCaretsBlink { get; set; };

		/**
		 * Whether additional carets are visible
		 * Set whether additional carets are visible
		 */
		Boolean AdditionalCaretsVisible { get; set; };

		/**
		 * How many selections are there?
		 */
		Int32 Selections { get; };

		/**
		 * Is every selected range empty?
		 */
		Boolean SelectionEmpty { get; };

		/**
		 * Which selection is the main selection
		 * Set the main selection
		 */
		Int32 MainSelection { get; set; };

		/**
		 * Return the caret position of the rectangular selection.
		 * Set the caret position of the rectangular selection.
		 */
		Int64 RectangularSelectionCaret { get; set; };

		/**
		 * Return the anchor position of the rectangular selection.
		 * Set the anchor position of the rectangular selection.
		 */
		Int64 RectangularSelectionAnchor { get; set; };

		/**
		 * Return the virtual space of the caret of the rectangular selection.
		 * Set the virtual space of the caret of the rectangular selection.
		 */
		Int64 RectangularSelectionCaretVirtualSpace { get; set; };

		/**
		 * Return the virtual space of the anchor of the rectangular selection.
		 * Set the virtual space of the anchor of the rectangular selection.
		 */
		Int64 RectangularSelectionAnchorVirtualSpace { get; set; };

		/**
		 * Return options for virtual space behaviour.
		 * Set options for virtual space behaviour.
		 */
		VirtualSpace VirtualSpaceOptions { get; set; };

		/**
		 * Get the modifier key used for rectangular selection.
		 */
		Int32 RectangularSelectionModifier { get; set; };

		/**
		 * Get the alpha of the selection.
		 * Set the alpha of the selection.
		 */
		Alpha AdditionalSelAlpha { get; set; };

		/**
		 * Get the foreground colour of additional carets.
		 * Set the foreground colour of additional carets.
		 */
		Int32 AdditionalCaretFore { get; set; };

		/**
		 * Get the identifier.
		 * Set the identifier reported as idFrom in notification messages.
		 */
		Int32 Identifier { get; set; };

		/**
		 * Get the tech.
		 * Set the technology used.
		 */
		Technology Technology { get; set; };

		/**
		 * Is the caret line always visible?
		 * Sets the caret line to always visible.
		 */
		Boolean CaretLineVisibleAlways { get; set; };

		/**
		 * Get the line end types currently allowed.
		 * Set the line end types that the application wants to use. May not be used if incompatible with lexer or encoding.
		 */
		LineEndType LineEndTypesAllowed { get; set; };

		/**
		 * Get the line end types currently recognised. May be a subset of the allowed types due to lexer limitation.
		 */
		LineEndType LineEndTypesActive { get; };

		/**
		 * Get the visibility for the end of line annotations for a view
		 * Set the visibility for the end of line annotations for a view
		 */
		EOLAnnotationVisible EOLAnnotationVisible { get; set; };

		/**
		 * Get the start of the range of style numbers used for end of line annotations
		 * Get the start of the range of style numbers used for end of line annotations
		 */
		Int32 EOLAnnotationStyleOffset { get; set; };

		/**
		 * Retrieve line character index state.
		 */
		LineCharacterIndexType LineCharacterIndex { get; };

		/**
		 * Retrieve the lexing language of the document.
		 */
		Int32 Lexer { get; };

		/**
		 * Bit set of LineEndType enumertion for which line ends beyond the standard
		 * LF, CR, and CRLF are supported by the lexer.
		 */
		LineEndType LineEndTypesSupported { get; };

		/**
		 * Where styles are duplicated by a feature such as active/inactive code
		 * return the distance between the two types.
		 */
		Int32 DistanceToSecondaryStyles { get; };

		/**
		 * Retrieve the number of named styles for the lexer.
		 */
		Int32 NamedStyles { get; };

		/**
		 * Retrieve bidirectional text display state.
		 * Set bidirectional text display state.
		 */
		Bidirectional Bidirectional { get; set; };

		/**
		 * Add text to the document at current position.
		 */
		void AddTextFromBuffer(Int64 length, Windows.Storage.Streams.IBuffer text);
		void AddText(Int64 length, String text);

		/**
		 * Add array of cells to document.
		 */
		void AddStyledText(Int64 length, UInt8[] c);

		/**
		 * Insert string at a position.
		 */
		void InsertTextFromBuffer(Int64 pos, Windows.Storage.Streams.IBuffer text);
		void InsertText(Int64 pos, String text);

		/**
		 * Change the text that is being inserted in response to SC_MOD_INSERTCHECK
		 */
		void ChangeInsertionFromBuffer(Int64 length, Windows.Storage.Streams.IBuffer text);
		void ChangeInsertion(Int64 length, String text);

		/**
		 * Delete all text in the document.
		 */
		void ClearAll();

		/**
		 * Delete a range of text in the document.
		 */
		void DeleteRange(Int64 start, Int64 lengthDelete);

		/**
		 * Set all style bytes to 0, remove all folding information.
		 */
		void ClearDocumentStyle();

		/**
		 * Redoes the next action on the undo history.
		 */
		void Redo();

		/**
		 * Select all the text in the document.
		 */
		void SelectAll();

		/**
		 * Remember the current position in the undo history as the position
		 * at which the document was saved.
		 */
		void SetSavePoint();

		/**
		 * Retrieve a buffer of cells.
		 * Returns the number of bytes in the buffer not including terminating NULs.
		 */
		Int64 GetStyledText(UInt64 tr);

		/**
		 * Retrieve a buffer of cells that can be past 2GB.
		 * Returns the number of bytes in the buffer not including terminating NULs.
		 */
		Int64 GetStyledTextFull(UInt64 tr);

		/**
		 * Are there any redoable actions in the undo history?
		 */
		Boolean CanRedo();

		/**
		 * Retrieve the line number at which a particular marker is located.
		 */
		Int64 MarkerLineFromHandle(Int32 markerHandle);

		/**
		 * Delete a marker.
		 */
		void MarkerDeleteHandle(Int32 markerHandle);

		/**
		 * Retrieve marker handles of a line
		 */
		Int32 MarkerHandleFromLine(Int64 line, Int32 which);

		/**
		 * Retrieve marker number of a marker handle
		 */
		Int32 MarkerNumberFromLine(Int64 line, Int32 which);

		/**
		 * Find the position from a point within the window.
		 */
		Int64 PositionFromPoint(Int32 x, Int32 y);

		/**
		 * Find the position from a point within the window but return
		 * INVALID_POSITION if not close to text.
		 */
		Int64 PositionFromPointClose(Int32 x, Int32 y);

		/**
		 * Set caret to start of a line and ensure it is visible.
		 */
		void GotoLine(Int64 line);

		/**
		 * Set caret to a position and ensure it is visible.
		 */
		void GotoPos(Int64 caret);

		/**
		 * Retrieve the text of the line containing the caret.
		 * Returns the index of the caret on the line.
		 * Result is NUL-terminated.
		 */
		Int64 GetCurLineWriteBuffer(Int64 length, Windows.Storage.Streams.IBuffer text);
		String GetCurLine(Int64 length);

		/**
		 * Convert all line endings in the document to one mode.
		 */
		void ConvertEOLs(EndOfLine eolMode);

		/**
		 * Set the current styling position to start.
		 * The unused parameter is no longer used and should be set to 0.
		 */
		void StartStyling(Int64 start, Int32 unused);

		/**
		 * Change style from current styling position for length characters to a style
		 * and move the current styling position to after this newly styled segment.
		 */
		void SetStyling(Int64 length, Int32 style);

		/**
		 * Clear explicit tabstops on a line.
		 */
		void ClearTabStops(Int64 line);

		/**
		 * Add an explicit tab stop for a line.
		 */
		void AddTabStop(Int64 line, Int32 x);

		/**
		 * Find the next explicit tab stop position on a line after a position.
		 */
		Int32 GetNextTabStop(Int64 line, Int32 x);

		/**
		 * Set the symbol used for a particular marker number.
		 */
		void MarkerDefine(Int32 markerNumber, MarkerSymbol markerSymbol);

		/**
		 * Enable/disable highlight for current folding block (smallest one that contains the caret)
		 */
		void MarkerEnableHighlight(Boolean enabled);

		/**
		 * Add a marker to a line, returning an ID which can be used to find or delete the marker.
		 */
		Int32 MarkerAdd(Int64 line, Int32 markerNumber);

		/**
		 * Delete a marker from a line.
		 */
		void MarkerDelete(Int64 line, Int32 markerNumber);

		/**
		 * Delete all markers with a particular number from all lines.
		 */
		void MarkerDeleteAll(Int32 markerNumber);

		/**
		 * Get a bit mask of all the markers set on a line.
		 */
		Int32 MarkerGet(Int64 line);

		/**
		 * Find the next line at or after lineStart that includes a marker in mask.
		 * Return -1 when no more lines.
		 */
		Int64 MarkerNext(Int64 lineStart, Int32 markerMask);

		/**
		 * Find the previous line before lineStart that includes a marker in mask.
		 */
		Int64 MarkerPrevious(Int64 lineStart, Int32 markerMask);

		/**
		 * Define a marker from a pixmap.
		 */
		void MarkerDefinePixmapFromBuffer(Int32 markerNumber, Windows.Storage.Streams.IBuffer pixmap);
		void MarkerDefinePixmap(Int32 markerNumber, String pixmap);

		/**
		 * Add a set of markers to a line.
		 */
		void MarkerAddSet(Int64 line, Int32 markerSet);

		/**
		 * Clear all the styles and make equivalent to the global default style.
		 */
		void StyleClearAll();

		/**
		 * Reset the default style to its state at startup
		 */
		void StyleResetDefault();

		/**
		 * Use the default or platform-defined colour for an element.
		 */
		void ResetElementColour(Element element);

		/**
		 * Set the foreground colour of the main and additional selections and whether to use this setting.
		 */
		void SetSelFore(Boolean useSetting, Int32 fore);

		/**
		 * Set the background colour of the main and additional selections and whether to use this setting.
		 */
		void SetSelBack(Boolean useSetting, Int32 back);

		/**
		 * When key+modifier combination keyDefinition is pressed perform sciCommand.
		 */
		void AssignCmdKey(Int32 keyDefinition, Int32 sciCommand);

		/**
		 * When key+modifier combination keyDefinition is pressed do nothing.
		 */
		void ClearCmdKey(Int32 keyDefinition);

		/**
		 * Drop all key mappings.
		 */
		void ClearAllCmdKeys();

		/**
		 * Set the styles for a segment of the document.
		 */
		void SetStylingExFromBuffer(Int64 length, Windows.Storage.Streams.IBuffer styles);
		void SetStylingEx(Int64 length, String styles);

		/**
		 * Start a sequence of actions that is undone and redone as a unit.
		 * May be nested.
		 */
		void BeginUndoAction();

		/**
		 * End a sequence of actions that is undone and redone as a unit.
		 */
		void EndUndoAction();

		/**
		 * Push one action onto undo history with no text
		 */
		void PushUndoActionType(Int32 type, Int64 pos);

		/**
		 * Set the text and length of the most recently pushed action
		 */
		void ChangeLastUndoActionTextFromBuffer(Int64 length, Windows.Storage.Streams.IBuffer text);
		void ChangeLastUndoActionText(Int64 length, String text);

		/**
		 * Set the foreground colour of all whitespace and whether to use this setting.
		 */
		void SetWhitespaceFore(Boolean useSetting, Int32 fore);

		/**
		 * Set the background colour of all whitespace and whether to use this setting.
		 */
		void SetWhitespaceBack(Boolean useSetting, Int32 back);

		/**
		 * Display a auto-completion list.
		 * The lengthEntered parameter indicates how many characters before
		 * the caret should be used to provide context.
		 */
		void AutoCShowFromBuffer(Int64 lengthEntered, Windows.Storage.Streams.IBuffer itemList);
		void AutoCShow(Int64 lengthEntered, String itemList);

		/**
		 * Remove the auto-completion list from the screen.
		 */
		void AutoCCancel();

		/**
		 * Is there an auto-completion list visible?
		 */
		Boolean AutoCActive();

		/**
		 * Retrieve the position of the caret when the auto-completion list was displayed.
		 */
		Int64 AutoCPosStart();

		/**
		 * User has selected an item so remove the list and insert the selection.
		 */
		void AutoCComplete();

		/**
		 * Define a set of character that when typed cancel the auto-completion list.
		 */
		void AutoCStopsFromBuffer(Windows.Storage.Streams.IBuffer characterSet);
		void AutoCStops(String characterSet);

		/**
		 * Select the item in the auto-completion list that starts with a string.
		 */
		void AutoCSelectFromBuffer(Windows.Storage.Streams.IBuffer select);
		void AutoCSelect(String select);

		/**
		 * Display a list of strings and send notification when user chooses one.
		 */
		void UserListShowFromBuffer(Int32 listType, Windows.Storage.Streams.IBuffer itemList);
		void UserListShow(Int32 listType, String itemList);

		/**
		 * Register an XPM image for use in autocompletion lists.
		 */
		void RegisterImageFromBuffer(Int32 type, Windows.Storage.Streams.IBuffer xpmData);
		void RegisterImage(Int32 type, String xpmData);

		/**
		 * Clear all the registered XPM images.
		 */
		void ClearRegisteredImages();

		/**
		 * Count characters between two positions.
		 */
		Int64 CountCharacters(Int64 start, Int64 end);

		/**
		 * Count code units between two positions.
		 */
		Int64 CountCodeUnits(Int64 start, Int64 end);

		/**
		 * Set caret to a position, while removing any existing selection.
		 */
		void SetEmptySelection(Int64 caret);

		/**
		 * Find some text in the document.
		 */
		Int64 FindText(FindOption searchFlags, UInt64 ft);

		/**
		 * Find some text in the document.
		 */
		Int64 FindTextFull(FindOption searchFlags, UInt64 ft);

		/**
		 * Draw the document into a display context such as a printer.
		 */
		Int64 FormatRange(Boolean draw, UInt64 fr);

		/**
		 * Draw the document into a display context such as a printer.
		 */
		Int64 FormatRangeFull(Boolean draw, UInt64 fr);

		/**
		 * Retrieve the contents of a line.
		 * Returns the length of the line.
		 */
		Int64 GetLineWriteBuffer(Int64 line, Windows.Storage.Streams.IBuffer text);
		String GetLine(Int64 line);

		/**
		 * Select a range of text.
		 */
		void SetSel(Int64 anchor, Int64 caret);

		/**
		 * Retrieve the selected text.
		 * Return the length of the text.
		 * Result is NUL-terminated.
		 */
		Int64 GetSelTextWriteBuffer(Windows.Storage.Streams.IBuffer text);
		String GetSelText();

		/**
		 * Retrieve a range of text.
		 * Return the length of the text.
		 */
		Int64 GetTextRange(UInt64 tr);

		/**
		 * Retrieve a range of text that can be past 2GB.
		 * Return the length of the text.
		 */
		Int64 GetTextRangeFull(UInt64 tr);

		/**
		 * Draw the selection either highlighted or in normal (non-highlighted) style.
		 */
		void HideSelection(Boolean hide);

		/**
		 * Retrieve the x value of the point in the window where a position is displayed.
		 */
		Int32 PointXFromPosition(Int64 pos);

		/**
		 * Retrieve the y value of the point in the window where a position is displayed.
		 */
		Int32 PointYFromPosition(Int64 pos);

		/**
		 * Retrieve the line containing a position.
		 */
		Int64 LineFromPosition(Int64 pos);

		/**
		 * Retrieve the position at the start of a line.
		 */
		Int64 PositionFromLine(Int64 line);

		/**
		 * Scroll horizontally and vertically.
		 */
		void LineScroll(Int64 columns, Int64 lines);

		/**
		 * Ensure the caret is visible.
		 */
		void ScrollCaret();

		/**
		 * Scroll the argument positions and the range between them into view giving
		 * priority to the primary position then the secondary position.
		 * This may be used to make a search match visible.
		 */
		void ScrollRange(Int64 secondary, Int64 primary);

		/**
		 * Replace the selected text with the argument text.
		 */
		void ReplaceSelFromBuffer(Windows.Storage.Streams.IBuffer text);
		void ReplaceSel(String text);

		/**
		 * Null operation.
		 */
		void Null();

		/**
		 * Will a paste succeed?
		 */
		Boolean CanPaste();

		/**
		 * Are there any undoable actions in the undo history?
		 */
		Boolean CanUndo();

		/**
		 * Delete the undo history.
		 */
		void EmptyUndoBuffer();

		/**
		 * Undo one action in the undo history.
		 */
		void Undo();

		/**
		 * Cut the selection to the clipboard.
		 */
		void Cut();

		/**
		 * Copy the selection to the clipboard.
		 */
		void Copy();

		/**
		 * Paste the contents of the clipboard into the document replacing the selection.
		 */
		void Paste();

		/**
		 * Clear the selection.
		 */
		void Clear();

		/**
		 * Replace the contents of the document with the argument text.
		 */
		void SetTextFromBuffer(Windows.Storage.Streams.IBuffer text);
		void SetText(String text);

		/**
		 * Retrieve all the text in the document.
		 * Returns number of characters retrieved.
		 * Result is NUL-terminated.
		 */
		Int64 GetTextWriteBuffer(Int64 length, Windows.Storage.Streams.IBuffer text);
		String GetText(Int64 length);

		/**
		 * Sets both the start and end of the target in one call.
		 */
		void SetTargetRange(Int64 start, Int64 end);

		/**
		 * Make the target range start and end be the same as the selection range start and end.
		 */
		void TargetFromSelection();

		/**
		 * Sets the target to the whole document.
		 */
		void TargetWholeDocument();

		/**
		 * Replace the target text with the argument text.
		 * Text is counted so it can contain NULs.
		 * Returns the length of the replacement text.
		 */
		Int64 ReplaceTargetFromBuffer(Int64 length, Windows.Storage.Streams.IBuffer text);
		Int64 ReplaceTarget(Int64 length, String text);

		/**
		 * Replace the target text with the argument text after \d processing.
		 * Text is counted so it can contain NULs.
		 * Looks for \d where d is between 1 and 9 and replaces these with the strings
		 * matched in the last search operation which were surrounded by \( and \).
		 * Returns the length of the replacement text including any change
		 * caused by processing the \d patterns.
		 */
		Int64 ReplaceTargetREFromBuffer(Int64 length, Windows.Storage.Streams.IBuffer text);
		Int64 ReplaceTargetRE(Int64 length, String text);

		/**
		 * Replace the target text with the argument text but ignore prefix and suffix that
		 * are the same as current.
		 */
		Int64 ReplaceTargetMinimalFromBuffer(Int64 length, Windows.Storage.Streams.IBuffer text);
		Int64 ReplaceTargetMinimal(Int64 length, String text);

		/**
		 * Search for a counted string in the target and set the target to the found
		 * range. Text is counted so it can contain NULs.
		 * Returns start of found range or -1 for failure in which case target is not moved.
		 */
		Int64 SearchInTargetFromBuffer(Int64 length, Windows.Storage.Streams.IBuffer text);
		Int64 SearchInTarget(Int64 length, String text);

		/**
		 * Show a call tip containing a definition near position pos.
		 */
		void CallTipShowFromBuffer(Int64 pos, Windows.Storage.Streams.IBuffer definition);
		void CallTipShow(Int64 pos, String definition);

		/**
		 * Remove the call tip from the screen.
		 */
		void CallTipCancel();

		/**
		 * Is there an active call tip?
		 */
		Boolean CallTipActive();

		/**
		 * Retrieve the position where the caret was before displaying the call tip.
		 */
		Int64 CallTipPosStart();

		/**
		 * Highlight a segment of the definition.
		 */
		void CallTipSetHlt(Int64 highlightStart, Int64 highlightEnd);

		/**
		 * Find the display line of a document line taking hidden lines into account.
		 */
		Int64 VisibleFromDocLine(Int64 docLine);

		/**
		 * Find the document line of a display line taking hidden lines into account.
		 */
		Int64 DocLineFromVisible(Int64 displayLine);

		/**
		 * The number of display lines needed to wrap a document line
		 */
		Int64 WrapCount(Int64 docLine);

		/**
		 * Make a range of lines visible.
		 */
		void ShowLines(Int64 lineStart, Int64 lineEnd);

		/**
		 * Make a range of lines invisible.
		 */
		void HideLines(Int64 lineStart, Int64 lineEnd);

		/**
		 * Switch a header line between expanded and contracted.
		 */
		void ToggleFold(Int64 line);

		/**
		 * Switch a header line between expanded and contracted and show some text after the line.
		 */
		void ToggleFoldShowTextFromBuffer(Int64 line, Windows.Storage.Streams.IBuffer text);
		void ToggleFoldShowText(Int64 line, String text);

		/**
		 * Set the default fold display text.
		 */
		void SetDefaultFoldDisplayTextFromBuffer(Windows.Storage.Streams.IBuffer text);
		void SetDefaultFoldDisplayText(String text);

		/**
		 * Get the default fold display text.
		 */
		Int32 GetDefaultFoldDisplayTextWriteBuffer(Windows.Storage.Streams.IBuffer text);
		String GetDefaultFoldDisplayText();

		/**
		 * Expand or contract a fold header.
		 */
		void FoldLine(Int64 line, FoldAction action);

		/**
		 * Expand or contract a fold header and its children.
		 */
		void FoldChildren(Int64 line, FoldAction action);

		/**
		 * Expand a fold header and all children. Use the level argument instead of the line's current level.
		 */
		void ExpandChildren(Int64 line, FoldLevel level);

		/**
		 * Expand or contract all fold headers.
		 */
		void FoldAll(FoldAction action);

		/**
		 * Ensure a particular line is visible by expanding any header line hiding it.
		 */
		void EnsureVisible(Int64 line);

		/**
		 * Ensure a particular line is visible by expanding any header line hiding it.
		 * Use the currently set visibility policy to determine which range to display.
		 */
		void EnsureVisibleEnforcePolicy(Int64 line);

		/**
		 * Get position of start of word.
		 */
		Int64 WordStartPosition(Int64 pos, Boolean onlyWordCharacters);

		/**
		 * Get position of end of word.
		 */
		Int64 WordEndPosition(Int64 pos, Boolean onlyWordCharacters);

		/**
		 * Is the range start..end considered a word?
		 */
		Boolean IsRangeWord(Int64 start, Int64 end);

		/**
		 * Measure the pixel width of some text in a particular style.
		 * NUL terminated text argument.
		 * Does not handle tab or control characters.
		 */
		Int32 TextWidthFromBuffer(Int32 style, Windows.Storage.Streams.IBuffer text);
		Int32 TextWidth(Int32 style, String text);

		/**
		 * Retrieve the height of a particular line of text in pixels.
		 */
		Int32 TextHeight(Int64 line);

		/**
		 * Append a string to the end of the document without changing the selection.
		 */
		void AppendTextFromBuffer(Int64 length, Windows.Storage.Streams.IBuffer text);
		void AppendText(Int64 length, String text);

		/**
		 * Join the lines in the target.
		 */
		void LinesJoin();

		/**
		 * Split the lines in the target into lines that are less wide than pixelWidth
		 * where possible.
		 */
		void LinesSplit(Int32 pixelWidth);

		/**
		 * Set one of the colours used as a chequerboard pattern in the fold margin
		 */
		void SetFoldMarginColour(Boolean useSetting, Int32 back);

		/**
		 * Set the other colour used as a chequerboard pattern in the fold margin
		 */
		void SetFoldMarginHiColour(Boolean useSetting, Int32 fore);

		/**
		 * Move caret down one line.
		 */
		void LineDown();

		/**
		 * Move caret down one line extending selection to new caret position.
		 */
		void LineDownExtend();

		/**
		 * Move caret up one line.
		 */
		void LineUp();

		/**
		 * Move caret up one line extending selection to new caret position.
		 */
		void LineUpExtend();

		/**
		 * Move caret left one character.
		 */
		void CharLeft();

		/**
		 * Move caret left one character extending selection to new caret position.
		 */
		void CharLeftExtend();

		/**
		 * Move caret right one character.
		 */
		void CharRight();

		/**
		 * Move caret right one character extending selection to new caret position.
		 */
		void CharRightExtend();

		/**
		 * Move caret left one word.
		 */
		void WordLeft();

		/**
		 * Move caret left one word extending selection to new caret position.
		 */
		void WordLeftExtend();

		/**
		 * Move caret right one word.
		 */
		void WordRight();

		/**
		 * Move caret right one word extending selection to new caret position.
		 */
		void WordRightExtend();

		/**
		 * Move caret to first position on line.
		 */
		void Home();

		/**
		 * Move caret to first position on line extending selection to new caret position.
		 */
		void HomeExtend();

		/**
		 * Move caret to last position on line.
		 */
		void LineEnd();

		/**
		 * Move caret to last position on line extending selection to new caret position.
		 */
		void LineEndExtend();

		/**
		 * Move caret to first position in document.
		 */
		void DocumentStart();

		/**
		 * Move caret to first position in document extending selection to new caret position.
		 */
		void DocumentStartExtend();

		/**
		 * Move caret to last position in document.
		 */
		void DocumentEnd();

		/**
		 * Move caret to last position in document extending selection to new caret position.
		 */
		void DocumentEndExtend();

		/**
		 * Move caret one page up.
		 */
		void PageUp();

		/**
		 * Move caret one page up extending selection to new caret position.
		 */
		void PageUpExtend();

		/**
		 * Move caret one page down.
		 */
		void PageDown();

		/**
		 * Move caret one page down extending selection to new caret position.
		 */
		void PageDownExtend();

		/**
		 * Switch from insert to overtype mode or the reverse.
		 */
		void EditToggleOvertype();

		/**
		 * Cancel any modes such as call tip or auto-completion list display.
		 */
		void Cancel();

		/**
		 * Delete the selection or if no selection, the character before the caret.
		 */
		void DeleteBack();

		/**
		 * If selection is empty or all on one line replace the selection with a tab character.
		 * If more than one line selected, indent the lines.
		 */
		void Tab();

		/**
		 * Indent the current and selected lines.
		 */
		void LineIndent();

		/**
		 * If selection is empty or all on one line dedent the line if caret is at start, else move caret.
		 * If more than one line selected, dedent the lines.
		 */
		void BackTab();

		/**
		 * Dedent the current and selected lines.
		 */
		void LineDedent();

		/**
		 * Insert a new line, may use a CRLF, CR or LF depending on EOL mode.
		 */
		void NewLine();

		/**
		 * Insert a Form Feed character.
		 */
		void FormFeed();

		/**
		 * Move caret to before first visible character on line.
		 * If already there move to first character on line.
		 */
		void VCHome();

		/**
		 * Like VCHome but extending selection to new caret position.
		 */
		void VCHomeExtend();

		/**
		 * Magnify the displayed text by increasing the sizes by 1 point.
		 */
		void ZoomIn();

		/**
		 * Make the displayed text smaller by decreasing the sizes by 1 point.
		 */
		void ZoomOut();

		/**
		 * Delete the word to the left of the caret.
		 */
		void DelWordLeft();

		/**
		 * Delete the word to the right of the caret.
		 */
		void DelWordRight();

		/**
		 * Delete the word to the right of the caret, but not the trailing non-word characters.
		 */
		void DelWordRightEnd();

		/**
		 * Cut the line containing the caret.
		 */
		void LineCut();

		/**
		 * Delete the line containing the caret.
		 */
		void LineDelete();

		/**
		 * Switch the current line with the previous.
		 */
		void LineTranspose();

		/**
		 * Reverse order of selected lines.
		 */
		void LineReverse();

		/**
		 * Duplicate the current line.
		 */
		void LineDuplicate();

		/**
		 * Transform the selection to lower case.
		 */
		void LowerCase();

		/**
		 * Transform the selection to upper case.
		 */
		void UpperCase();

		/**
		 * Scroll the document down, keeping the caret visible.
		 */
		void LineScrollDown();

		/**
		 * Scroll the document up, keeping the caret visible.
		 */
		void LineScrollUp();

		/**
		 * Delete the selection or if no selection, the character before the caret.
		 * Will not delete the character before at the start of a line.
		 */
		void DeleteBackNotLine();

		/**
		 * Move caret to first position on display line.
		 */
		void HomeDisplay();

		/**
		 * Move caret to first position on display line extending selection to
		 * new caret position.
		 */
		void HomeDisplayExtend();

		/**
		 * Move caret to last position on display line.
		 */
		void LineEndDisplay();

		/**
		 * Move caret to last position on display line extending selection to new
		 * caret position.
		 */
		void LineEndDisplayExtend();

		/**
		 * Like Home but when word-wrap is enabled goes first to start of display line
		 * HomeDisplay, then to start of document line Home.
		 */
		void HomeWrap();

		/**
		 * Like HomeExtend but when word-wrap is enabled extends first to start of display line
		 * HomeDisplayExtend, then to start of document line HomeExtend.
		 */
		void HomeWrapExtend();

		/**
		 * Like LineEnd but when word-wrap is enabled goes first to end of display line
		 * LineEndDisplay, then to start of document line LineEnd.
		 */
		void LineEndWrap();

		/**
		 * Like LineEndExtend but when word-wrap is enabled extends first to end of display line
		 * LineEndDisplayExtend, then to start of document line LineEndExtend.
		 */
		void LineEndWrapExtend();

		/**
		 * Like VCHome but when word-wrap is enabled goes first to start of display line
		 * VCHomeDisplay, then behaves like VCHome.
		 */
		void VCHomeWrap();

		/**
		 * Like VCHomeExtend but when word-wrap is enabled extends first to start of display line
		 * VCHomeDisplayExtend, then behaves like VCHomeExtend.
		 */
		void VCHomeWrapExtend();

		/**
		 * Copy the line containing the caret.
		 */
		void LineCopy();

		/**
		 * Move the caret inside current view if it's not there already.
		 */
		void MoveCaretInsideView();

		/**
		 * How many characters are on a line, including end of line characters?
		 */
		Int64 LineLength(Int64 line);

		/**
		 * Highlight the characters at two positions.
		 */
		void BraceHighlight(Int64 posA, Int64 posB);

		/**
		 * Use specified indicator to highlight matching braces instead of changing their style.
		 */
		void BraceHighlightIndicator(Boolean useSetting, Int32 indicator);

		/**
		 * Highlight the character at a position indicating there is no matching brace.
		 */
		void BraceBadLight(Int64 pos);

		/**
		 * Use specified indicator to highlight non matching brace instead of changing its style.
		 */
		void BraceBadLightIndicator(Boolean useSetting, Int32 indicator);

		/**
		 * Find the position of a matching brace or INVALID_POSITION if no match.
		 * The maxReStyle must be 0 for now. It may be defined in a future release.
		 */
		Int64 BraceMatch(Int64 pos, Int32 maxReStyle);

		/**
		 * Similar to BraceMatch, but matching starts at the explicit start position.
		 */
		Int64 BraceMatchNext(Int64 pos, Int64 startPos);

		/**
		 * Add a new vertical edge to the view.
		 */
		void MultiEdgeAddLine(Int64 column, Int32 edgeColour);

		/**
		 * Clear all vertical edges.
		 */
		void MultiEdgeClearAll();

		/**
		 * Sets the current caret position to be the search anchor.
		 */
		void SearchAnchor();

		/**
		 * Find some text starting at the search anchor.
		 * Does not ensure the selection is visible.
		 */
		Int64 SearchNextFromBuffer(FindOption searchFlags, Windows.Storage.Streams.IBuffer text);
		Int64 SearchNext(FindOption searchFlags, String text);

		/**
		 * Find some text starting at the search anchor and moving backwards.
		 * Does not ensure the selection is visible.
		 */
		Int64 SearchPrevFromBuffer(FindOption searchFlags, Windows.Storage.Streams.IBuffer text);
		Int64 SearchPrev(FindOption searchFlags, String text);

		/**
		 * Set whether a pop up menu is displayed automatically when the user presses
		 * the wrong mouse button on certain areas.
		 */
		void UsePopUp(PopUp popUpMode);

		/**
		 * Create a new document object.
		 * Starts with reference count of 1 and not selected into editor.
		 */
		UInt64 CreateDocument(Int64 bytes, DocumentOption documentOptions);

		/**
		 * Extend life of document.
		 */
		void AddRefDocument(UInt64 doc);

		/**
		 * Release a reference to the document, deleting document if it fades to black.
		 */
		void ReleaseDocument(UInt64 doc);

		/**
		 * Move to the previous change in capitalisation.
		 */
		void WordPartLeft();

		/**
		 * Move to the previous change in capitalisation extending selection
		 * to new caret position.
		 */
		void WordPartLeftExtend();

		/**
		 * Move to the change next in capitalisation.
		 */
		void WordPartRight();

		/**
		 * Move to the next change in capitalisation extending selection
		 * to new caret position.
		 */
		void WordPartRightExtend();

		/**
		 * Set the way the display area is determined when a particular line
		 * is to be moved to by Find, FindNext, GotoLine, etc.
		 */
		void SetVisiblePolicy(VisiblePolicy visiblePolicy, Int32 visibleSlop);

		/**
		 * Delete back from the current position to the start of the line.
		 */
		void DelLineLeft();

		/**
		 * Delete forwards from the current position to the end of the line.
		 */
		void DelLineRight();

		/**
		 * Set the last x chosen value to be the caret x position.
		 */
		void ChooseCaretX();

		/**
		 * Set the focus to this Scintilla widget.
		 */
		void GrabFocus();

		/**
		 * Set the way the caret is kept visible when going sideways.
		 * The exclusion zone is given in pixels.
		 */
		void SetXCaretPolicy(CaretPolicy caretPolicy, Int32 caretSlop);

		/**
		 * Set the way the line the caret is on is kept visible.
		 * The exclusion zone is given in lines.
		 */
		void SetYCaretPolicy(CaretPolicy caretPolicy, Int32 caretSlop);

		/**
		 * Move caret down one paragraph (delimited by empty lines).
		 */
		void ParaDown();

		/**
		 * Extend selection down one paragraph (delimited by empty lines).
		 */
		void ParaDownExtend();

		/**
		 * Move caret up one paragraph (delimited by empty lines).
		 */
		void ParaUp();

		/**
		 * Extend selection up one paragraph (delimited by empty lines).
		 */
		void ParaUpExtend();

		/**
		 * Given a valid document position, return the previous position taking code
		 * page into account. Returns 0 if passed 0.
		 */
		Int64 PositionBefore(Int64 pos);

		/**
		 * Given a valid document position, return the next position taking code
		 * page into account. Maximum value returned is the last position in the document.
		 */
		Int64 PositionAfter(Int64 pos);

		/**
		 * Given a valid document position, return a position that differs in a number
		 * of characters. Returned value is always between 0 and last position in document.
		 */
		Int64 PositionRelative(Int64 pos, Int64 relative);

		/**
		 * Given a valid document position, return a position that differs in a number
		 * of UTF-16 code units. Returned value is always between 0 and last position in document.
		 * The result may point half way (2 bytes) inside a non-BMP character.
		 */
		Int64 PositionRelativeCodeUnits(Int64 pos, Int64 relative);

		/**
		 * Copy a range of text to the clipboard. Positions are clipped into the document.
		 */
		void CopyRange(Int64 start, Int64 end);

		/**
		 * Copy argument text to the clipboard.
		 */
		void CopyTextFromBuffer(Int64 length, Windows.Storage.Streams.IBuffer text);
		void CopyText(Int64 length, String text);

		/**
		 * Set the selection mode to stream (SC_SEL_STREAM) or rectangular (SC_SEL_RECTANGLE/SC_SEL_THIN) or
		 * by lines (SC_SEL_LINES) without changing MoveExtendsSelection.
		 */
		void ChangeSelectionMode(SelectionMode selectionMode);

		/**
		 * Retrieve the position of the start of the selection at the given line (INVALID_POSITION if no selection on this line).
		 */
		Int64 GetLineSelStartPosition(Int64 line);

		/**
		 * Retrieve the position of the end of the selection at the given line (INVALID_POSITION if no selection on this line).
		 */
		Int64 GetLineSelEndPosition(Int64 line);

		/**
		 * Move caret down one line, extending rectangular selection to new caret position.
		 */
		void LineDownRectExtend();

		/**
		 * Move caret up one line, extending rectangular selection to new caret position.
		 */
		void LineUpRectExtend();

		/**
		 * Move caret left one character, extending rectangular selection to new caret position.
		 */
		void CharLeftRectExtend();

		/**
		 * Move caret right one character, extending rectangular selection to new caret position.
		 */
		void CharRightRectExtend();

		/**
		 * Move caret to first position on line, extending rectangular selection to new caret position.
		 */
		void HomeRectExtend();

		/**
		 * Move caret to before first visible character on line.
		 * If already there move to first character on line.
		 * In either case, extend rectangular selection to new caret position.
		 */
		void VCHomeRectExtend();

		/**
		 * Move caret to last position on line, extending rectangular selection to new caret position.
		 */
		void LineEndRectExtend();

		/**
		 * Move caret one page up, extending rectangular selection to new caret position.
		 */
		void PageUpRectExtend();

		/**
		 * Move caret one page down, extending rectangular selection to new caret position.
		 */
		void PageDownRectExtend();

		/**
		 * Move caret to top of page, or one page up if already at top of page.
		 */
		void StutteredPageUp();

		/**
		 * Move caret to top of page, or one page up if already at top of page, extending selection to new caret position.
		 */
		void StutteredPageUpExtend();

		/**
		 * Move caret to bottom of page, or one page down if already at bottom of page.
		 */
		void StutteredPageDown();

		/**
		 * Move caret to bottom of page, or one page down if already at bottom of page, extending selection to new caret position.
		 */
		void StutteredPageDownExtend();

		/**
		 * Move caret left one word, position cursor at end of word.
		 */
		void WordLeftEnd();

		/**
		 * Move caret left one word, position cursor at end of word, extending selection to new caret position.
		 */
		void WordLeftEndExtend();

		/**
		 * Move caret right one word, position cursor at end of word.
		 */
		void WordRightEnd();

		/**
		 * Move caret right one word, position cursor at end of word, extending selection to new caret position.
		 */
		void WordRightEndExtend();

		/**
		 * Reset the set of characters for whitespace and word characters to the defaults.
		 */
		void SetCharsDefault();

		/**
		 * Enlarge the document to a particular size of text bytes.
		 */
		void Allocate(Int64 bytes);

		/**
		 * Returns the target converted to UTF8.
		 * Return the length in bytes.
		 */
		Int64 TargetAsUTF8WriteBuffer(Windows.Storage.Streams.IBuffer s);
		String TargetAsUTF8();

		/**
		 * Set the length of the utf8 argument for calling EncodedFromUTF8.
		 * Set to -1 and the string will be measured to the first nul.
		 */
		void SetLengthForEncode(Int64 bytes);

		/**
		 * Translates a UTF8 string into the document encoding.
		 * Return the length of the result in bytes.
		 * On error return 0.
		 */
		Int64 EncodedFromUTF8WriteBuffer(Windows.Storage.Streams.IBuffer utf8, Windows.Storage.Streams.IBuffer encoded);
		String EncodedFromUTF8(String utf8);

		/**
		 * Find the position of a column on a line taking into account tabs and
		 * multi-byte characters. If beyond end of line, return line end position.
		 */
		Int64 FindColumn(Int64 line, Int64 column);

		/**
		 * Switch between sticky and non-sticky: meant to be bound to a key.
		 */
		void ToggleCaretSticky();

		/**
		 * Replace the selection with text like a rectangular paste.
		 */
		void ReplaceRectangularFromBuffer(Int64 length, Windows.Storage.Streams.IBuffer text);
		void ReplaceRectangular(Int64 length, String text);

		/**
		 * Duplicate the selection. If selection empty duplicate the line containing the caret.
		 */
		void SelectionDuplicate();

		/**
		 * Turn a indicator on over a range.
		 */
		void IndicatorFillRange(Int64 start, Int64 lengthFill);

		/**
		 * Turn a indicator off over a range.
		 */
		void IndicatorClearRange(Int64 start, Int64 lengthClear);

		/**
		 * Are any indicators present at pos?
		 */
		Int32 IndicatorAllOnFor(Int64 pos);

		/**
		 * What value does a particular indicator have at a position?
		 */
		Int32 IndicatorValueAt(Int32 indicator, Int64 pos);

		/**
		 * Where does a particular indicator start?
		 */
		Int64 IndicatorStart(Int32 indicator, Int64 pos);

		/**
		 * Where does a particular indicator end?
		 */
		Int64 IndicatorEnd(Int32 indicator, Int64 pos);

		/**
		 * Copy the selection, if selection empty copy the line with the caret
		 */
		void CopyAllowLine();

		/**
		 * Cut the selection, if selection empty cut the line with the caret
		 */
		void CutAllowLine();

		/**
		 * Which symbol was defined for markerNumber with MarkerDefine
		 */
		Int32 MarkerSymbolDefined(Int32 markerNumber);

		/**
		 * Clear the margin text on all lines
		 */
		void MarginTextClearAll();

		/**
		 * Clear the annotations from all lines
		 */
		void AnnotationClearAll();

		/**
		 * Release all extended (>255) style numbers
		 */
		void ReleaseAllExtendedStyles();

		/**
		 * Allocate some extended (>255) style numbers and return the start of the range
		 */
		Int32 AllocateExtendedStyles(Int32 numberStyles);

		/**
		 * Add a container action to the undo stack
		 */
		void AddUndoAction(Int32 token, UndoFlags flags);

		/**
		 * Find the position of a character from a point within the window.
		 */
		Int64 CharPositionFromPoint(Int32 x, Int32 y);

		/**
		 * Find the position of a character from a point within the window.
		 * Return INVALID_POSITION if not close to text.
		 */
		Int64 CharPositionFromPointClose(Int32 x, Int32 y);

		/**
		 * Clear selections to a single empty stream selection
		 */
		void ClearSelections();

		/**
		 * Set a simple selection
		 */
		void SetSelection(Int64 caret, Int64 anchor);

		/**
		 * Add a selection
		 */
		void AddSelection(Int64 caret, Int64 anchor);

		/**
		 * Find the selection index for a point. -1 when not at a selection.
		 */
		Int32 SelectionFromPoint(Int32 x, Int32 y);

		/**
		 * Drop one selection
		 */
		void DropSelectionN(Int32 selection);

		/**
		 * Set the main selection to the next selection.
		 */
		void RotateSelection();

		/**
		 * Swap that caret and anchor of the main selection.
		 */
		void SwapMainAnchorCaret();

		/**
		 * Add the next occurrence of the main selection to the set of selections as main.
		 * If the current selection is empty then select word around caret.
		 */
		void MultipleSelectAddNext();

		/**
		 * Add each occurrence of the main selection in the target to the set of selections.
		 * If the current selection is empty then select word around caret.
		 */
		void MultipleSelectAddEach();

		/**
		 * Indicate that the internal state of a lexer has changed over a range and therefore
		 * there may be a need to redraw.
		 */
		Int32 ChangeLexerState(Int64 start, Int64 end);

		/**
		 * Find the next line at or after lineStart that is a contracted fold header line.
		 * Return -1 when no more lines.
		 */
		Int64 ContractedFoldNext(Int64 lineStart);

		/**
		 * Centre current line in window.
		 */
		void VerticalCentreCaret();

		/**
		 * Move the selected lines up one line, shifting the line above after the selection
		 */
		void MoveSelectedLinesUp();

		/**
		 * Move the selected lines down one line, shifting the line below before the selection
		 */
		void MoveSelectedLinesDown();

		/**
		 * Define a marker from RGBA data.
		 * It has the width and height from RGBAImageSetWidth/Height
		 */
		void MarkerDefineRGBAImageFromBuffer(Int32 markerNumber, Windows.Storage.Streams.IBuffer pixels);
		void MarkerDefineRGBAImage(Int32 markerNumber, String pixels);

		/**
		 * Register an RGBA image for use in autocompletion lists.
		 * It has the width and height from RGBAImageSetWidth/Height
		 */
		void RegisterRGBAImageFromBuffer(Int32 type, Windows.Storage.Streams.IBuffer pixels);
		void RegisterRGBAImage(Int32 type, String pixels);

		/**
		 * Scroll to start of document.
		 */
		void ScrollToStart();

		/**
		 * Scroll to end of document.
		 */
		void ScrollToEnd();

		/**
		 * Create an ILoader*.
		 */
		UInt64 CreateLoader(Int64 bytes, DocumentOption documentOptions);

		/**
		 * On macOS, show a find indicator.
		 */
		void FindIndicatorShow(Int64 start, Int64 end);

		/**
		 * On macOS, flash a find indicator, then fade out.
		 */
		void FindIndicatorFlash(Int64 start, Int64 end);

		/**
		 * On macOS, hide the find indicator.
		 */
		void FindIndicatorHide();

		/**
		 * Move caret to before first visible character on display line.
		 * If already there move to first character on display line.
		 */
		void VCHomeDisplay();

		/**
		 * Like VCHomeDisplay but extending selection to new caret position.
		 */
		void VCHomeDisplayExtend();

		/**
		 * Remove a character representation.
		 */
		void ClearRepresentationFromBuffer(Windows.Storage.Streams.IBuffer encodedCharacter);
		void ClearRepresentation(String encodedCharacter);

		/**
		 * Clear representations to default.
		 */
		void ClearAllRepresentations();

		/**
		 * Clear the end of annotations from all lines
		 */
		void EOLAnnotationClearAll();

		/**
		 * Request line character index be created or its use count increased.
		 */
		void AllocateLineCharacterIndex(LineCharacterIndexType lineCharacterIndex);

		/**
		 * Decrease use count of line character index and remove if 0.
		 */
		void ReleaseLineCharacterIndex(LineCharacterIndexType lineCharacterIndex);

		/**
		 * Retrieve the document line containing a position measured in index units.
		 */
		Int64 LineFromIndexPosition(Int64 pos, LineCharacterIndexType lineCharacterIndex);

		/**
		 * Retrieve the position measured in index units at the start of a document line.
		 */
		Int64 IndexPositionFromLine(Int64 line, LineCharacterIndexType lineCharacterIndex);

		/**
		 * Start notifying the container of all key presses and commands.
		 */
		void StartRecord();

		/**
		 * Stop notifying the container of all key presses and commands.
		 */
		void StopRecord();

		/**
		 * Colourise a segment of the document using the current lexing language.
		 */
		void Colourise(Int64 start, Int64 end);

		/**
		 * For private communication between an application and a known lexer.
		 */
		UInt64 PrivateLexerCall(Int32 operation, UInt64 pointer);

		/**
		 * Retrieve a '\n' separated list of properties understood by the current lexer.
		 * Result is NUL-terminated.
		 */
		Int32 PropertyNamesWriteBuffer(Windows.Storage.Streams.IBuffer names);
		String PropertyNames();

		/**
		 * Retrieve the type of a property.
		 */
		TypeProperty PropertyTypeFromBuffer(Windows.Storage.Streams.IBuffer name);
		TypeProperty PropertyType(String name);

		/**
		 * Describe a property.
		 * Result is NUL-terminated.
		 */
		Int32 DescribePropertyWriteBuffer(Windows.Storage.Streams.IBuffer name, Windows.Storage.Streams.IBuffer description);
		String DescribeProperty(String name);

		/**
		 * Retrieve a '\n' separated list of descriptions of the keyword sets understood by the current lexer.
		 * Result is NUL-terminated.
		 */
		Int32 DescribeKeyWordSetsWriteBuffer(Windows.Storage.Streams.IBuffer descriptions);
		String DescribeKeyWordSets();

		/**
		 * Allocate a set of sub styles for a particular base style, returning start of range
		 */
		Int32 AllocateSubStyles(Int32 styleBase, Int32 numberStyles);

		/**
		 * Free allocated sub styles
		 */
		void FreeSubStyles();

		/**
		 * Retrieve the name of a style.
		 * Result is NUL-terminated.
		 */
		Int32 NameOfStyleWriteBuffer(Int32 style, Windows.Storage.Streams.IBuffer name);
		String NameOfStyle(Int32 style);

		/**
		 * Retrieve a ' ' separated list of style tags like "literal quoted string".
		 * Result is NUL-terminated.
		 */
		Int32 TagsOfStyleWriteBuffer(Int32 style, Windows.Storage.Streams.IBuffer tags);
		String TagsOfStyle(Int32 style);

		/**
		 * Retrieve a description of a style.
		 * Result is NUL-terminated.
		 */
		Int32 DescriptionOfStyleWriteBuffer(Int32 style, Windows.Storage.Streams.IBuffer description);
		String DescriptionOfStyle(Int32 style);

		/**
		 * Returns the character byte at the position.
		 */
		Int32 GetCharAt(Int64 pos);

		/**
		 * Returns the style byte at the position.
		 */
		Int32 GetStyleAt(Int64 pos);

		/**
		 * Returns the unsigned style byte at the position.
		 */
		Int32 GetStyleIndexAt(Int64 pos);

		/**
		 * Get the locale for displaying text.
		 */
		Int32 GetFontLocaleWriteBuffer(Windows.Storage.Streams.IBuffer localeName);
		String GetFontLocale();

		/**
		 * Get the layer used for a marker that is drawn in the text area, not the margin.
		 */
		Layer MarkerGetLayer(Int32 markerNumber);

		/**
		 * Retrieve the type of a margin.
		 */
		MarginType GetMarginTypeN(Int32 margin);

		/**
		 * Retrieve the width of a margin in pixels.
		 */
		Int32 GetMarginWidthN(Int32 margin);

		/**
		 * Retrieve the marker mask of a margin.
		 */
		Int32 GetMarginMaskN(Int32 margin);

		/**
		 * Retrieve the mouse click sensitivity of a margin.
		 */
		Boolean GetMarginSensitiveN(Int32 margin);

		/**
		 * Retrieve the cursor shown in a margin.
		 */
		CursorShape GetMarginCursorN(Int32 margin);

		/**
		 * Retrieve the background colour of a margin
		 */
		Int32 GetMarginBackN(Int32 margin);

		/**
		 * Get the foreground colour of a style.
		 */
		Int32 StyleGetFore(Int32 style);

		/**
		 * Get the background colour of a style.
		 */
		Int32 StyleGetBack(Int32 style);

		/**
		 * Get is a style bold or not.
		 */
		Boolean StyleGetBold(Int32 style);

		/**
		 * Get is a style italic or not.
		 */
		Boolean StyleGetItalic(Int32 style);

		/**
		 * Get the size of characters of a style.
		 */
		Int32 StyleGetSize(Int32 style);

		/**
		 * Get the font of a style.
		 * Returns the length of the fontName
		 * Result is NUL-terminated.
		 */
		Int32 StyleGetFontWriteBuffer(Int32 style, Windows.Storage.Streams.IBuffer fontName);
		String StyleGetFont(Int32 style);

		/**
		 * Get is a style to have its end of line filled or not.
		 */
		Boolean StyleGetEOLFilled(Int32 style);

		/**
		 * Get is a style underlined or not.
		 */
		Boolean StyleGetUnderline(Int32 style);

		/**
		 * Get is a style mixed case, or to force upper or lower case.
		 */
		CaseVisible StyleGetCase(Int32 style);

		/**
		 * Get the character get of the font in a style.
		 */
		CharacterSet StyleGetCharacterSet(Int32 style);

		/**
		 * Get is a style visible or not.
		 */
		Boolean StyleGetVisible(Int32 style);

		/**
		 * Get is a style changeable or not (read only).
		 * Experimental feature, currently buggy.
		 */
		Boolean StyleGetChangeable(Int32 style);

		/**
		 * Get is a style a hotspot or not.
		 */
		Boolean StyleGetHotSpot(Int32 style);

		/**
		 * Get the size of characters of a style in points multiplied by 100
		 */
		Int32 StyleGetSizeFractional(Int32 style);

		/**
		 * Get the weight of characters of a style.
		 */
		FontWeight StyleGetWeight(Int32 style);

		/**
		 * Get whether a style may be monospaced.
		 */
		Boolean StyleGetCheckMonospaced(Int32 style);

		/**
		 * Get the stretch of characters of a style.
		 */
		FontStretch StyleGetStretch(Int32 style);

		/**
		 * Get the invisible representation for a style.
		 */
		Int32 StyleGetInvisibleRepresentationWriteBuffer(Int32 style, Windows.Storage.Streams.IBuffer representation);
		String StyleGetInvisibleRepresentation(Int32 style);

		/**
		 * Get the colour of an element.
		 */
		Int32 GetElementColour(Element element);

		/**
		 * Get whether an element has been set by SetElementColour.
		 * When false, a platform-defined or default colour is used.
		 */
		Boolean GetElementIsSet(Element element);

		/**
		 * Get whether an element supports translucency.
		 */
		Boolean GetElementAllowsTranslucent(Element element);

		/**
		 * Get the colour of an element.
		 */
		Int32 GetElementBaseColour(Element element);

		/**
		 * Get the set of characters making up words for when moving or selecting by word.
		 * Returns the number of characters
		 */
		Int32 GetWordCharsWriteBuffer(Windows.Storage.Streams.IBuffer characters);
		String GetWordChars();

		/**
		 * What is the type of an action?
		 */
		Int32 GetUndoActionType(Int32 action);

		/**
		 * What is the position of an action?
		 */
		Int64 GetUndoActionPosition(Int32 action);

		/**
		 * What is the text of an action?
		 */
		Int32 GetUndoActionTextWriteBuffer(Int32 action, Windows.Storage.Streams.IBuffer text);
		String GetUndoActionText(Int32 action);

		/**
		 * Retrieve the style of an indicator.
		 */
		IndicatorStyle IndicGetStyle(Int32 indicator);

		/**
		 * Retrieve the foreground colour of an indicator.
		 */
		Int32 IndicGetFore(Int32 indicator);

		/**
		 * Retrieve whether indicator drawn under or over text.
		 */
		Boolean IndicGetUnder(Int32 indicator);

		/**
		 * Retrieve the hover style of an indicator.
		 */
		IndicatorStyle IndicGetHoverStyle(Int32 indicator);

		/**
		 * Retrieve the foreground hover colour of an indicator.
		 */
		Int32 IndicGetHoverFore(Int32 indicator);

		/**
		 * Retrieve the attributes of an indicator.
		 */
		IndicFlag IndicGetFlags(Int32 indicator);

		/**
		 * Retrieve the stroke width of an indicator.
		 */
		Int32 IndicGetStrokeWidth(Int32 indicator);

		/**
		 * Retrieve the extra styling information for a line.
		 */
		Int32 GetLineState(Int64 line);

		/**
		 * Retrieve the number of columns that a line is indented.
		 */
		Int32 GetLineIndentation(Int64 line);

		/**
		 * Retrieve the position before the first non indentation character on a line.
		 */
		Int64 GetLineIndentPosition(Int64 line);

		/**
		 * Retrieve the column number of a position, taking tab width into account.
		 */
		Int64 GetColumn(Int64 pos);

		/**
		 * Get the position after the last visible characters on a line.
		 */
		Int64 GetLineEndPosition(Int64 line);

		/**
		 * Retrieve the text in the target.
		 */
		Int64 GetTargetTextWriteBuffer(Windows.Storage.Streams.IBuffer text);
		String GetTargetText();

		/**
		 * Retrieve the fold level of a line.
		 */
		FoldLevel GetFoldLevel(Int64 line);

		/**
		 * Find the last child line of a header line.
		 */
		Int64 GetLastChild(Int64 line, FoldLevel level);

		/**
		 * Find the parent line of a child line.
		 */
		Int64 GetFoldParent(Int64 line);

		/**
		 * Is a line visible?
		 */
		Boolean GetLineVisible(Int64 line);

		/**
		 * Is a header line expanded?
		 */
		Boolean GetFoldExpanded(Int64 line);

		/**
		 * Retrieve the value of a tag from a regular expression search.
		 * Result is NUL-terminated.
		 */
		Int32 GetTagWriteBuffer(Int32 tagNumber, Windows.Storage.Streams.IBuffer tagValue);
		String GetTag(Int32 tagNumber);

		/**
		 * Get multi edge positions.
		 */
		Int64 GetMultiEdgeColumn(Int32 which);

		/**
		 * Get the fore colour for active hotspots.
		 */
		Int32 GetHotspotActiveFore();

		/**
		 * Get the back colour for active hotspots.
		 */
		Int32 GetHotspotActiveBack();

		/**
		 * Get the set of characters making up whitespace for when moving or selecting by word.
		 */
		Int32 GetWhitespaceCharsWriteBuffer(Windows.Storage.Streams.IBuffer characters);
		String GetWhitespaceChars();

		/**
		 * Get the set of characters making up punctuation characters
		 */
		Int32 GetPunctuationCharsWriteBuffer(Windows.Storage.Streams.IBuffer characters);
		String GetPunctuationChars();

		/**
		 * Get currently selected item text in the auto-completion list
		 * Returns the length of the item text
		 * Result is NUL-terminated.
		 */
		Int32 AutoCGetCurrentTextWriteBuffer(Windows.Storage.Streams.IBuffer text);
		String AutoCGetCurrentText();

		/**
		 * Get the string to separate parts when copying a multiple selection.
		 */
		Int32 GetCopySeparatorWriteBuffer(Windows.Storage.Streams.IBuffer separator);
		String GetCopySeparator();

		/**
		 * Return a read-only pointer to a range of characters in the document.
		 * May move the gap so that the range is contiguous, but will only move up
		 * to lengthRange bytes.
		 */
		UInt64 GetRangePointer(Int64 start, Int64 lengthRange);

		/**
		 * Get the alpha fill colour of the given indicator.
		 */
		Alpha IndicGetAlpha(Int32 indicator);

		/**
		 * Get the alpha outline colour of the given indicator.
		 */
		Alpha IndicGetOutlineAlpha(Int32 indicator);

		/**
		 * Get the text in the text margin for a line
		 */
		Int32 MarginGetTextWriteBuffer(Int64 line, Windows.Storage.Streams.IBuffer text);
		String MarginGetText(Int64 line);

		/**
		 * Get the style number for the text margin for a line
		 */
		Int32 MarginGetStyle(Int64 line);

		/**
		 * Get the styles in the text margin for a line
		 */
		Int32 MarginGetStylesWriteBuffer(Int64 line, Windows.Storage.Streams.IBuffer styles);
		String MarginGetStyles(Int64 line);

		/**
		 * Get the annotation text for a line
		 */
		Int32 AnnotationGetTextWriteBuffer(Int64 line, Windows.Storage.Streams.IBuffer text);
		String AnnotationGetText(Int64 line);

		/**
		 * Get the style number for the annotations for a line
		 */
		Int32 AnnotationGetStyle(Int64 line);

		/**
		 * Get the annotation styles for a line
		 */
		Int32 AnnotationGetStylesWriteBuffer(Int64 line, Windows.Storage.Streams.IBuffer styles);
		String AnnotationGetStyles(Int64 line);

		/**
		 * Get the number of annotation lines for a line
		 */
		Int32 AnnotationGetLines(Int64 line);

		/**
		 * Return the caret position of the nth selection.
		 */
		Int64 GetSelectionNCaret(Int32 selection);

		/**
		 * Return the anchor position of the nth selection.
		 */
		Int64 GetSelectionNAnchor(Int32 selection);

		/**
		 * Return the virtual space of the caret of the nth selection.
		 */
		Int64 GetSelectionNCaretVirtualSpace(Int32 selection);

		/**
		 * Return the virtual space of the anchor of the nth selection.
		 */
		Int64 GetSelectionNAnchorVirtualSpace(Int32 selection);

		/**
		 * Returns the position at the start of the selection.
		 */
		Int64 GetSelectionNStart(Int32 selection);

		/**
		 * Returns the virtual space at the start of the selection.
		 */
		Int64 GetSelectionNStartVirtualSpace(Int32 selection);

		/**
		 * Returns the virtual space at the end of the selection.
		 */
		Int64 GetSelectionNEndVirtualSpace(Int32 selection);

		/**
		 * Returns the position at the end of the selection.
		 */
		Int64 GetSelectionNEnd(Int32 selection);

		/**
		 * Get the way a character is drawn.
		 * Result is NUL-terminated.
		 */
		Int32 GetRepresentationWriteBuffer(Windows.Storage.Streams.IBuffer encodedCharacter, Windows.Storage.Streams.IBuffer representation);
		String GetRepresentation(String encodedCharacter);

		/**
		 * Get the appearance of a representation.
		 */
		RepresentationAppearance GetRepresentationAppearanceFromBuffer(Windows.Storage.Streams.IBuffer encodedCharacter);
		RepresentationAppearance GetRepresentationAppearance(String encodedCharacter);

		/**
		 * Get the colour of a representation.
		 */
		Int32 GetRepresentationColourFromBuffer(Windows.Storage.Streams.IBuffer encodedCharacter);
		Int32 GetRepresentationColour(String encodedCharacter);

		/**
		 * Get the end of line annotation text for a line
		 */
		Int32 EOLAnnotationGetTextWriteBuffer(Int64 line, Windows.Storage.Streams.IBuffer text);
		String EOLAnnotationGetText(Int64 line);

		/**
		 * Get the style number for the end of line annotations for a line
		 */
		Int32 EOLAnnotationGetStyle(Int64 line);

		/**
		 * Get whether a feature is supported
		 */
		Boolean SupportsFeature(Supports feature);

		/**
		 * Retrieve a "property" value previously set with SetProperty.
		 * Result is NUL-terminated.
		 */
		Int32 GetPropertyWriteBuffer(Windows.Storage.Streams.IBuffer key, Windows.Storage.Streams.IBuffer value);
		String GetProperty(String key);

		/**
		 * Retrieve a "property" value previously set with SetProperty,
		 * with "$()" variable replacement on returned buffer.
		 * Result is NUL-terminated.
		 */
		Int32 GetPropertyExpandedWriteBuffer(Windows.Storage.Streams.IBuffer key, Windows.Storage.Streams.IBuffer value);
		String GetPropertyExpanded(String key);

		/**
		 * Retrieve a "property" value previously set with SetProperty,
		 * interpreted as an int AFTER any "$()" variable replacement.
		 */
		Int32 GetPropertyIntFromBuffer(Windows.Storage.Streams.IBuffer key, Int32 defaultValue);
		Int32 GetPropertyInt(String key, Int32 defaultValue);

		/**
		 * Retrieve the name of the lexer.
		 * Return the length of the text.
		 * Result is NUL-terminated.
		 */
		Int32 GetLexerLanguageWriteBuffer(Windows.Storage.Streams.IBuffer language);
		String GetLexerLanguage();

		/**
		 * The starting style number for the sub styles associated with a base style
		 */
		Int32 GetSubStylesStart(Int32 styleBase);

		/**
		 * The number of sub styles associated with a base style
		 */
		Int32 GetSubStylesLength(Int32 styleBase);

		/**
		 * For a sub style, return the base style, else return the argument.
		 */
		Int32 GetStyleFromSubStyle(Int32 subStyle);

		/**
		 * For a secondary style, return the primary style, else return the argument.
		 */
		Int32 GetPrimaryStyleFromStyle(Int32 style);

		/**
		 * Get the set of base styles that can be extended with sub styles
		 * Result is NUL-terminated.
		 */
		Int32 GetSubStyleBasesWriteBuffer(Windows.Storage.Streams.IBuffer styles);
		String GetSubStyleBases();

		/**
		 * Set the locale for displaying text.
		 */
		void SetFontLocaleFromBuffer(Windows.Storage.Streams.IBuffer localeName);
		void SetFontLocale(String localeName);

		/**
		 * Set the foreground colour used for a particular marker number.
		 */
		void MarkerSetFore(Int32 markerNumber, Int32 fore);

		/**
		 * Set the background colour used for a particular marker number.
		 */
		void MarkerSetBack(Int32 markerNumber, Int32 back);

		/**
		 * Set the background colour used for a particular marker number when its folding block is selected.
		 */
		void MarkerSetBackSelected(Int32 markerNumber, Int32 back);

		/**
		 * Set the foreground colour used for a particular marker number.
		 */
		void MarkerSetForeTranslucent(Int32 markerNumber, Int32 fore);

		/**
		 * Set the background colour used for a particular marker number.
		 */
		void MarkerSetBackTranslucent(Int32 markerNumber, Int32 back);

		/**
		 * Set the background colour used for a particular marker number when its folding block is selected.
		 */
		void MarkerSetBackSelectedTranslucent(Int32 markerNumber, Int32 back);

		/**
		 * Set the width of strokes used in .01 pixels so 50  = 1/2 pixel width.
		 */
		void MarkerSetStrokeWidth(Int32 markerNumber, Int32 hundredths);

		/**
		 * Set the alpha used for a marker that is drawn in the text area, not the margin.
		 */
		void MarkerSetAlpha(Int32 markerNumber, Alpha alpha);

		/**
		 * Set the layer used for a marker that is drawn in the text area, not the margin.
		 */
		void MarkerSetLayer(Int32 markerNumber, Layer layer);

		/**
		 * Set a margin to be either numeric or symbolic.
		 */
		void SetMarginTypeN(Int32 margin, MarginType marginType);

		/**
		 * Set the width of a margin to a width expressed in pixels.
		 */
		void SetMarginWidthN(Int32 margin, Int32 pixelWidth);

		/**
		 * Set a mask that determines which markers are displayed in a margin.
		 */
		void SetMarginMaskN(Int32 margin, Int32 mask);

		/**
		 * Make a margin sensitive or insensitive to mouse clicks.
		 */
		void SetMarginSensitiveN(Int32 margin, Boolean sensitive);

		/**
		 * Set the cursor shown when the mouse is inside a margin.
		 */
		void SetMarginCursorN(Int32 margin, CursorShape cursor);

		/**
		 * Set the background colour of a margin. Only visible for SC_MARGIN_COLOUR.
		 */
		void SetMarginBackN(Int32 margin, Int32 back);

		/**
		 * Set the foreground colour of a style.
		 */
		void StyleSetFore(Int32 style, Int32 fore);

		/**
		 * Set the background colour of a style.
		 */
		void StyleSetBack(Int32 style, Int32 back);

		/**
		 * Set a style to be bold or not.
		 */
		void StyleSetBold(Int32 style, Boolean bold);

		/**
		 * Set a style to be italic or not.
		 */
		void StyleSetItalic(Int32 style, Boolean italic);

		/**
		 * Set the size of characters of a style.
		 */
		void StyleSetSize(Int32 style, Int32 sizePoints);

		/**
		 * Set the font of a style.
		 */
		void StyleSetFontFromBuffer(Int32 style, Windows.Storage.Streams.IBuffer fontName);
		void StyleSetFont(Int32 style, String fontName);

		/**
		 * Set a style to have its end of line filled or not.
		 */
		void StyleSetEOLFilled(Int32 style, Boolean eolFilled);

		/**
		 * Set a style to be underlined or not.
		 */
		void StyleSetUnderline(Int32 style, Boolean underline);

		/**
		 * Set a style to be mixed case, or to force upper or lower case.
		 */
		void StyleSetCase(Int32 style, CaseVisible caseVisible);

		/**
		 * Set the size of characters of a style. Size is in points multiplied by 100.
		 */
		void StyleSetSizeFractional(Int32 style, Int32 sizeHundredthPoints);

		/**
		 * Set the weight of characters of a style.
		 */
		void StyleSetWeight(Int32 style, FontWeight weight);

		/**
		 * Set the character set of the font in a style.
		 */
		void StyleSetCharacterSet(Int32 style, CharacterSet characterSet);

		/**
		 * Set a style to be a hotspot or not.
		 */
		void StyleSetHotSpot(Int32 style, Boolean hotspot);

		/**
		 * Indicate that a style may be monospaced over ASCII graphics characters which enables optimizations.
		 */
		void StyleSetCheckMonospaced(Int32 style, Boolean checkMonospaced);

		/**
		 * Set the stretch of characters of a style.
		 */
		void StyleSetStretch(Int32 style, FontStretch stretch);

		/**
		 * Set the invisible representation for a style.
		 */
		void StyleSetInvisibleRepresentationFromBuffer(Int32 style, Windows.Storage.Streams.IBuffer representation);
		void StyleSetInvisibleRepresentation(Int32 style, String representation);

		/**
		 * Set the colour of an element. Translucency (alpha) may or may not be significant
		 * and this may depend on the platform. The alpha byte should commonly be 0xff for opaque.
		 */
		void SetElementColour(Element element, Int32 colourElement);

		/**
		 * Set a style to be visible or not.
		 */
		void StyleSetVisible(Int32 style, Boolean visible);

		/**
		 * Set the set of characters making up words for when moving or selecting by word.
		 * First sets defaults like SetCharsDefault.
		 */
		void SetWordCharsFromBuffer(Windows.Storage.Streams.IBuffer characters);
		void SetWordChars(String characters);

		/**
		 * Set an indicator to plain, squiggle or TT.
		 */
		void IndicSetStyle(Int32 indicator, IndicatorStyle indicatorStyle);

		/**
		 * Set the foreground colour of an indicator.
		 */
		void IndicSetFore(Int32 indicator, Int32 fore);

		/**
		 * Set an indicator to draw under text or over(default).
		 */
		void IndicSetUnder(Int32 indicator, Boolean under);

		/**
		 * Set a hover indicator to plain, squiggle or TT.
		 */
		void IndicSetHoverStyle(Int32 indicator, IndicatorStyle indicatorStyle);

		/**
		 * Set the foreground hover colour of an indicator.
		 */
		void IndicSetHoverFore(Int32 indicator, Int32 fore);

		/**
		 * Set the attributes of an indicator.
		 */
		void IndicSetFlags(Int32 indicator, IndicFlag flags);

		/**
		 * Set the stroke width of an indicator in hundredths of a pixel.
		 */
		void IndicSetStrokeWidth(Int32 indicator, Int32 hundredths);

		/**
		 * Used to hold extra styling information for each line.
		 */
		void SetLineState(Int64 line, Int32 state);

		/**
		 * Set a style to be changeable or not (read only).
		 * Experimental feature, currently buggy.
		 */
		void StyleSetChangeable(Int32 style, Boolean changeable);

		/**
		 * Define a set of characters that when typed will cause the autocompletion to
		 * choose the selected item.
		 */
		void AutoCSetFillUpsFromBuffer(Windows.Storage.Streams.IBuffer characterSet);
		void AutoCSetFillUps(String characterSet);

		/**
		 * Change the indentation of a line to a number of columns.
		 */
		void SetLineIndentation(Int64 line, Int32 indentation);

		/**
		 * Enlarge the number of lines allocated.
		 */
		void AllocateLines(Int64 lines);

		/**
		 * Set the start position in order to change when backspacing removes the calltip.
		 */
		void CallTipSetPosStart(Int64 posStart);

		/**
		 * Set the background colour for the call tip.
		 */
		void CallTipSetBack(Int32 back);

		/**
		 * Set the foreground colour for the call tip.
		 */
		void CallTipSetFore(Int32 fore);

		/**
		 * Set the foreground colour for the highlighted part of the call tip.
		 */
		void CallTipSetForeHlt(Int32 fore);

		/**
		 * Enable use of STYLE_CALLTIP and set call tip tab size in pixels.
		 */
		void CallTipUseStyle(Int32 tabSize);

		/**
		 * Set position of calltip, above or below text.
		 */
		void CallTipSetPosition(Boolean above);

		/**
		 * Set the fold level of a line.
		 * This encodes an integer level along with flags indicating whether the
		 * line is a header and whether it is effectively white space.
		 */
		void SetFoldLevel(Int64 line, FoldLevel level);

		/**
		 * Show the children of a header line.
		 */
		void SetFoldExpanded(Int64 line, Boolean expanded);

		/**
		 * Set some style options for folding.
		 */
		void SetFoldFlags(FoldFlag flags);

		/**
		 * Set a fore colour for active hotspots.
		 */
		void SetHotspotActiveFore(Boolean useSetting, Int32 fore);

		/**
		 * Set a back colour for active hotspots.
		 */
		void SetHotspotActiveBack(Boolean useSetting, Int32 back);

		/**
		 * Set the set of characters making up whitespace for when moving or selecting by word.
		 * Should be called after SetWordChars.
		 */
		void SetWhitespaceCharsFromBuffer(Windows.Storage.Streams.IBuffer characters);
		void SetWhitespaceChars(String characters);

		/**
		 * Set the set of characters making up punctuation characters
		 * Should be called after SetWordChars.
		 */
		void SetPunctuationCharsFromBuffer(Windows.Storage.Streams.IBuffer characters);
		void SetPunctuationChars(String characters);

		/**
		 * Set the string to separate parts when copying a multiple selection.
		 */
		void SetCopySeparatorFromBuffer(Windows.Storage.Streams.IBuffer separator);
		void SetCopySeparator(String separator);

		/**
		 * Set the alpha fill colour of the given indicator.
		 */
		void IndicSetAlpha(Int32 indicator, Alpha alpha);

		/**
		 * Set the alpha outline colour of the given indicator.
		 */
		void IndicSetOutlineAlpha(Int32 indicator, Alpha alpha);

		/**
		 * Set the text in the text margin for a line
		 */
		void MarginSetTextFromBuffer(Int64 line, Windows.Storage.Streams.IBuffer text);
		void MarginSetText(Int64 line, String text);

		/**
		 * Set the style number for the text margin for a line
		 */
		void MarginSetStyle(Int64 line, Int32 style);

		/**
		 * Set the style in the text margin for a line
		 */
		void MarginSetStylesFromBuffer(Int64 line, Windows.Storage.Streams.IBuffer styles);
		void MarginSetStyles(Int64 line, String styles);

		/**
		 * Set the annotation text for a line
		 */
		void AnnotationSetTextFromBuffer(Int64 line, Windows.Storage.Streams.IBuffer text);
		void AnnotationSetText(Int64 line, String text);

		/**
		 * Set the style number for the annotations for a line
		 */
		void AnnotationSetStyle(Int64 line, Int32 style);

		/**
		 * Set the annotation styles for a line
		 */
		void AnnotationSetStylesFromBuffer(Int64 line, Windows.Storage.Streams.IBuffer styles);
		void AnnotationSetStyles(Int64 line, String styles);

		/**
		 * Set the caret position of the nth selection.
		 */
		void SetSelectionNCaret(Int32 selection, Int64 caret);

		/**
		 * Set the anchor position of the nth selection.
		 */
		void SetSelectionNAnchor(Int32 selection, Int64 anchor);

		/**
		 * Set the virtual space of the caret of the nth selection.
		 */
		void SetSelectionNCaretVirtualSpace(Int32 selection, Int64 space);

		/**
		 * Set the virtual space of the anchor of the nth selection.
		 */
		void SetSelectionNAnchorVirtualSpace(Int32 selection, Int64 space);

		/**
		 * Sets the position that starts the selection - this becomes the anchor.
		 */
		void SetSelectionNStart(Int32 selection, Int64 anchor);

		/**
		 * Sets the position that ends the selection - this becomes the currentPosition.
		 */
		void SetSelectionNEnd(Int32 selection, Int64 caret);

		/**
		 * Set the foreground colour of additional selections.
		 * Must have previously called SetSelFore with non-zero first argument for this to have an effect.
		 */
		void SetAdditionalSelFore(Int32 fore);

		/**
		 * Set the background colour of additional selections.
		 * Must have previously called SetSelBack with non-zero first argument for this to have an effect.
		 */
		void SetAdditionalSelBack(Int32 back);

		/**
		 * Set the width for future RGBA image data.
		 */
		void RGBAImageSetWidth(Int32 width);

		/**
		 * Set the height for future RGBA image data.
		 */
		void RGBAImageSetHeight(Int32 height);

		/**
		 * Set the scale factor in percent for future RGBA image data.
		 */
		void RGBAImageSetScale(Int32 scalePercent);

		/**
		 * Set the way a character is drawn.
		 */
		void SetRepresentationFromBuffer(Windows.Storage.Streams.IBuffer encodedCharacter, Windows.Storage.Streams.IBuffer representation);
		void SetRepresentation(String encodedCharacter, String representation);

		/**
		 * Set the appearance of a representation.
		 */
		void SetRepresentationAppearanceFromBuffer(Windows.Storage.Streams.IBuffer encodedCharacter, RepresentationAppearance appearance);
		void SetRepresentationAppearance(String encodedCharacter, RepresentationAppearance appearance);

		/**
		 * Set the colour of a representation.
		 */
		void SetRepresentationColourFromBuffer(Windows.Storage.Streams.IBuffer encodedCharacter, Int32 colour);
		void SetRepresentationColour(String encodedCharacter, Int32 colour);

		/**
		 * Set the end of line annotation text for a line
		 */
		void EOLAnnotationSetTextFromBuffer(Int64 line, Windows.Storage.Streams.IBuffer text);
		void EOLAnnotationSetText(Int64 line, String text);

		/**
		 * Set the style number for the end of line annotations for a line
		 */
		void EOLAnnotationSetStyle(Int64 line, Int32 style);

		/**
		 * Set up a value that may be used by a lexer for some optional feature.
		 */
		void SetPropertyFromBuffer(Windows.Storage.Streams.IBuffer key, Windows.Storage.Streams.IBuffer value);
		void SetProperty(String key, String value);

		/**
		 * Set up the key words used by the lexer.
		 */
		void SetKeyWordsFromBuffer(Int32 keyWordSet, Windows.Storage.Streams.IBuffer keyWords);
		void SetKeyWords(Int32 keyWordSet, String keyWords);

		/**
		 * Set the identifiers that are shown in a particular style
		 */
		void SetIdentifiersFromBuffer(Int32 style, Windows.Storage.Streams.IBuffer identifiers);
		void SetIdentifiers(Int32 style, String identifiers);

		/**
		 * Set the lexer from an ILexer*.
		 */
		void SetILexer(UInt64 ilexer);
	}
}
